

 

# 牛客面经

## 字节数据中台一面7.5

#### 1.position[的粘滞定位](https://blog.csdn.net/qq_35585701/article/details/81040901)sticky：

position:sticky是css定位新增属性；可以说是相对定位relative和固定定位fixed的结合；它主要用在对scroll事件的监听上；简单来说，在滑动过程中，某个元素距离其父元素的距离达到sticky粘性定位的要求时(比如top：100px)；position:sticky这时的效果相当于fixed定位，固定到适当位置。

#### 2.[vue是如何获取到DOM节点变化的](https://blog.csdn.net/weixin_33727510/article/details/93515195)：

直接给相应的元素加id,然后再document.getElementById("id");获取，然后设置相应属性或样式

使用ref,给相应的元素加ref=“name” 然后再this.$refs.name获取到该元素

#### 3.客户端渲染和服务器端渲染的最重要的区别就是**究竟是谁来完成html文件的完整拼接，**如果是在服务器端完成的(浏览器拿到这个html文件之后就可以直接解析展示了)，然后返回给客户端，就是服务器端渲染，而如果是前端做了更多的工作完成了html的拼接，则就是客户端渲染。

服务器端渲染的优缺点是怎样的？

**优点：**

1. **前端耗时少。**因为后端拼接完了html，浏览器只需要直接渲染出来**。**
2. **有利于SEO。**因为在后端有完整的html页面，所以爬虫更容易爬取获得信息，更有利于seo。
3. **无需占用客户端资源**。即解析模板的工作完全交由后端来做，客户端只要解析标准的html页面即可，这样对于客户端的资源占用更少，尤其是移动端，也可以更省电。
4. **后端生成静态化文件**。即生成缓存片段，这样就可以减少数据库查询浪费的时间了，且对于数据变化不大的页面非常高效 。

**缺点：**

1. **不利于前后端分离，开发效率低。**使用服务器端渲染，则无法进行分工合作，则对于前端复杂度高的项目，不利于项目高效开发。另外，如果是服务器端渲染，则**前端一般就是写一个静态html文件**，然后**后端再修改为模板**，这样是非常低效的，并且还常常需要前后端共同完成修改的动作； **或者是前端直接完成html模板，然后交由后端**。另外，如果后端改了模板，前端还需要根据改动的模板再调节css，这样使得前后端联调的时间增加。
2. **占用服务器端资源**。即服务器端完成html模板的解析，如果请求较多，会对服务器造成一定的访问压力。而如果使用前端渲染，就是把这些解析的压力分摊了前端，而这里确实完全交给了一个服务器。



## 同花顺前端提前批一面面经7.5

#### 1.window.onload 和$(document).ready() 区别

window.onload除了文档加载解析完成以外，图片等一系列外部资源也加载完成了，不能同时编写多个，如果有多个window.onload方法只会执行一个

$(document).ready() DOM结构绘制完毕后就执行，可以同时编写多个，并且都可以得到执行 

#### 2.vue生命周期有哪些，create和mounted的区别

beforeCreate 钩子函数，在实例初始化之后，在数据监听和事件配置之前触发

created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。

beforeMount 钩子函数，在组件被挂载到页面之前触发。

mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API 获取到页面中的 DOM 元素。

beforeUpdate 钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补丁之前

updated 钩子函数，虚拟 DOM 重新渲染和打补丁之后调用。

beforeDestroy 钩子函数，在实例销毁之前调用。

destroyed 钩子函数，在实例销毁之后调用，

#### 3.vm.$nextTick什么用

`this.$nextTick`是一个回调函数，这个回调函数会在下次 DOM 更新结束之后执行。我们可以理解成，Vue 在更新 DOM时是异步执行的。当数据发生变化，Vue将开启一个异步更新队列，视图需要等队列中所有数据变化完成之后，再统一进行更新。

#### 4.webpack提升性能的方法

1.缩小文件的搜索范围，resolve字段告诉webpack怎么去搜索文件。

2.把网页依赖的基础模块抽离出来打包到dll文件中，当需要导入的模块存在于某个dll中时，这个模块不再被打包，而是去dll中获取

3.使用HappyPack开启多进程Loader转换(在整个构建流程中，最耗时的就是Loader对文件的转换操作了，而运行在Node.js之上的Webpack是单线程模型的，也就是只能一个一个文件进行处理，不能并行处理)。

#### 5.webpack如何减少打包体积

1.去除不必要的插件

2.用dll文件的方式提取第三方库

3.代码压缩

#### 6.常见的HTTP状态码

> 一般 1XX 代表服务器接收到请求、2XX 代表成功、3XX 代表重定向、4XX 代表客户端错误、5XX 代表服务器端错误。

列举几种常见的：

> 200-请求成功、202-服务器端已经收到请求消息，但是尚未进行处理
> 301-永久移动、302-临时移动、304（要你去拿缓存）、307（要你去拿缓存） 
> 400-客户端请求的语法错误、403（有这个资源，但是没有访问权限） 、404-请求的资源不存在
> 500-服务器内部错误。

#### 7.vite

目前 vue3.0 的版本已经发布了 此次除了可以通过 vue-cli 和 webpack 搭建脚手架外 官方还提供了一种新的脚手架搭建工具 **vite**，Vite 是 Vue 作者开发的一款意图取代 webpack 的工具 。

## 百度提前批7.6

#### 1.说说用express写个接口的流程，从app.use说起：

<img src="https://gitee.com/chenyipeng9/blog/raw/master/img/Snipaste_2021-9907-07_07-34-18.png" style="zoom: 50%;" />

<img src="https://gitee.com/chenyipeng9/blog/raw/master/img/Snipaste_2021-8807-07_07-57-29.png" style="zoom: 50%;" />



#### 2.说说会数据库哪些，口述了一个简单的查询：

MongoDb数据库

database：数据仓库，mongoDB数据库软件中可以建立多个数据仓库，比如一个网站服务器可以放置多个网站应用，每个网站应用需要独立的数据仓库

collection：集合，一组数据的集合，可以理解为JavaScript中的数组，每个数据仓库可以建立多个集合，集合可以理解为类别，比如用户信息和商品信息就要存储在不同的集合中

document：文档，一条具体的数据，可以理解为JavaScript中的对象，json文件，每个集合中可以建立多个文档，

field：字段，文档中的属性名称，可以理解为JavaScript中的对象属性

Mongoose第三方库：

#### 3.nginx....

#### 4.PM2：是一个带有负载均衡功能的Node应用的进程管理器.

## 360Web 提前批一面7.6

#### 1.前端的性能监控，异常上报的具体流程是什么？

**前端性能监控：**

1.最常见的性能监控需求则是需要我们统计用户从开始请求页面到所有 `DOM`元素渲染完成的时间，也就是俗称的首屏加载时间， `DOM`提供了这一接口，监听 `document`的 `DOMContentLoaded`事件与 `window`的 `load`事件可统计页面首屏加载时间即所有 `DOM`渲染时间。

2.但是以上时间的监控过于粗略，例如我们想统计文档的网络加载耗时、解析 `DOM`的耗时与渲染 `DOM`的耗时，就不太好办到了，所幸的是浏览器提供了 `window.performance`接口，

**异常上报：**

而这些异常和性能数据如何上报呢？一般说来，为了避免对业务产生的影响，会单独建立日志服务器和日志域名，但对于不同的域名，又会产生跨域的问题。我们可以通过构造空的 `Image`对象来解决，亦或是通过设定跨域请求头部 `Access-Control-Allow-Origin:*`来解决。此外，如果上报的性能和日志数据高频触发，则可以在页面 `unload`时统一上报，而 `unload`时的异步请求又可能会被浏览器所忽略，且不能改为同步请求。此时 `navigator.sendBeacon API`可算帮了我们大忙，它可用于通过 `HTTP`将少量数据异步传输到 `Web`服务器。而忽略页面 `unload`时的影响。

#### 2.React和Vue你认为有什么区别

相同点：
React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；中心思想相同：一切都是组件，组件实例之间可以嵌套；都提供合理的钩子函数，可以让开发者定制化地去处理需求；都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载；在组件开发中都支持mixins的特性。
不同点：
React采用的Virtual DOM会对渲染出来的结果做脏检查；Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。

注：JSX是一种JavaScript的语法扩展，运用于[React](https://baike.baidu.com/item/React/18077599)架构中，其格式比较像是模版语言，但事实上完全是在[JavaScript](https://baike.baidu.com/item/JavaScript/321142)内部实现的

#### 3.ES6的模块化规范与CommonJS模块化规范的区别：

- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

  ```
  第二个差异是因为 CommonJS 加载的是一个对象（即module.exports属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。
  ```

- CommonJS 模块的`require()`是同步加载模块，ES6 模块的`import`命令是异

#### 4.简述前端的代码编译发布的流程

vue-cli 可视化界面？==》 server  ---》  build项目优化  ----》创建一个服务器将打包完成的项目放到服务器上？

#### 5.简述完整的git流程

git用于版本管理的工具：

使用git进行项目管理前，需要在本地初始化一个git仓库(git init)；

整个本地的git流程包括：工作目录、暂存区、git仓库,

`git status` 查看文件状态,  

git add 工作目录中的提交到暂存区， 

git commit -m 暂存区提交到本地仓库

`git branch` 查看分支

`git branch 分支名称` 创建分支

`git checkout 分支名称` 切换分支

(保持当前分支暂存区是干净的状态,或则会将该分支暂存区上的文件带到切换后分支的暂存区上)

`git merge 来源分支` 合并分支

`git branch -d 分支名称` 删除分支

#### 6.场景描述：[百度](https://www.nowcoder.com/jump/super-jump/word?word=百度)搜索框输入“222”，然后下方出现一个下拉框，如何去实现

使用autocomplete自动补全插件，将搜索的数据放进数组，而后提供给autocomplete自动补全插件使用，结合ajax从后端拿取数据。

#### 7.场景描述：[百度](https://www.nowcoder.com/jump/super-jump/word?word=百度)搜索框输入“摇一摇”，点击回车后，页面会有一个摇摆的效果，你会如何实现？

css3动画  + rotate 

## 同花顺提前批前端一面凉经7.6

#### 1.前端学习看了那些书？

html、css方面：head first html 与css，css权威指南 + B站  

JS方面：红宝书 + 犀牛书 + javascript Dom编程艺术 + 阮一峰ES6标准入门

计算机网络方面：图解http请求、谢希仁计算机网络

web性能方面：web性能权威指南

## 同花顺提前批前端一面7.6

#### 1.如何遍历对象？

for...in   循环遍历对象自身的和继承的可枚举属性

Object.keys(obj)   返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。

Object.getOwnPropertyNames(obj)  返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。

Object.getOwnPropertySymbols  返回一个数组，包含对象自身的所有 Symbol 属性的键名。

Reflect.ownKeys 返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。

#### 2.手写promise思路###

.....

## 联易融提前批前端一面面经7.6######

操作系统....

## 同花顺前端一面面经7.7#######

<img src="https://gitee.com/chenyipeng9/blog/raw/master/img/Snipaste_2021-07-08_08-22-55.png" style="zoom:67%;" />

## 猫眼前端一面、二面7.3

#### 1.构造函数污染window， 在不改变调用方式的前提下 不污染的方法（不能使用new())

```
// 构造函数：
// new调用时，this指向新创建出来的对象
// 作为普通函数调用时，this指向window，这就造成了全局环境的污染
// 可以在构造函数内部判断this的指向，来避免全局环境的污染
function Person(name, age, job){
    if (this instanceof Person){
        this.name = name;
        this.age = age;
        this.job = job;
		console.log('this 指向： ',this)
    } else {
    	return new Person(name, age, job);
    }
}
```

#### 2.[前端](https://www.nowcoder.com/jump/super-jump/word?word=前端)向后端发送请求数据， 除了 请求体 和 url 还有别的传参方式吗？

URL、请求体、报文头部。----》cookie？

## 字节实习前端一面面经：

#### 1.webpack的原理：

我认为 webpack 的主要原理是，它将所有的资源都看成是一个模块，并且把页面逻辑当作一个整体，通过一个给定的入口文件，webpack 从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过 loader 和 plugins 处理后，然后打包在一起，最后输出一个浏览器可识别的 JS 文件。

####  2.transition和animation区别

transition： 是过渡，关注的是CSS property的变化，需要一个事件去触发，比如点击。
animation：是动画，关注的是元素本身，而不是样式属性，可以使用多个关键帧来实现自由动画，不需要任何触发事件，而且可以通过@keyframe控制当前帧属性，更为灵活。

## TP-LINK杭州秋招提前批-前端二面面经

#### 1.讲一讲JS的垃圾回收机制：引用计数和标记清除

1、标记清除法：

JavaScript最常用的垃圾收集方式。当变量进入环境时，这个变量标记为“进入环境”；而当变量离开环境时，则将其标记为“离开环境”。可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境， 或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。说到底，如何标记变量其实并不重要，关键在于采取什么策略。

2、引用计数法：

不太常见的垃圾收集策略。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则该值的引用次数就是1；如果同一个值又被赋给另一个变量，则该值的引用次数加1；如果包含对该值引用的变量又取得了另外一个值，则该值的引用次数减1。当该值的引用次数变为0时，则可以回收其占用的内存空间。当垃圾回收器下一次运行时，就会释放那些引用次数为0的值所占用的内存。

## 自如前端实习面经 40min(OC)

#### 1.flex:auto和flex:1的区别：

flex：flex-grow  flex-shrink  flex-bias

flex：1  ---》 1  1 0 ；flex：n1，n2   -----》  n1  n2  0； flex：n  l   -----》n   1   l；

flex-bias弹性基准是弹性伸缩布局的核心，可以取如下几种情况的值：
1.指定大小，比如200px，则就按着200px作为基准尺寸，之后剩余的主轴空间部分，或是超过主轴空间部分在跟进弹性伸缩量进行配置。

2.直接为0，则直接按照伸缩量来分配主轴空间

3.指定auto，则看有没有设置弹性项目宽高，有的话以其为基准，之后同1；没有的话以项目所占主轴空间大小为基准之后同1

4.指定百分比，以主轴的百分之多少为基准，之后同1

所以综上只有0比较特殊，直接根据伸缩量分配主轴空间，其他的就先确定基准所占大小根据后续剩余空间或超出空间进行分配。

flex：initial  ===》  flex：0  1 auto

flex：auto ====》  flex：1   1  auto

flex：none  ===>    flex:   0   0   auto

flex:   n   ====>  flex: n   1  0

#### 2.异步编程看代码

```
async function async1() {
    console.log("async1 start");
    await async2();
    console.log("async1 end");
}

async function async2() {
    console.log("async2");
}

async1();
console.log('start');

async1 start
async2
start
async1 end
```

```
async function async1() {
    console.log("async1 start");
    await async2();
    console.log("async1 end");
    setTimeout(() => {
        console.log('timer1');
    }, 0)
}
async function async2() {
    setTimeout(() => {
        console.log('timer2')
    }, 0)
    console.log("async2");
}
async1();
setTimeout(() => {
    console.log('timer3')
}, 0);
console.log("start")

async1 start
async2    
start     
async1 end
timer2    
timer3    
timer1    
```

## 欢聚前端实习一二面面经

#### 1.如果在Vue里面改变一个数组的某个元素，Vue可以检测到变化吗？为什么？

说了下数组变化侦测的原理。

#### 2.使用Vue提供的哪个API去解决上一个问题？

#### 3.display:none和visibility:hidden

<img src="https://gitee.com/kszycyp/blog/raw/master/img/%E6%80%BB%E7%BB%93.jpg" style="zoom: 33%;" />

```
transition: property duration timing-function delay;
过渡是针对于某个CSS属性的，
```

#### 3.display:none和visibility:hidden

**overflow规定当内容溢出元素框时发生的事情。**

overflow：visible 默认值，内容不会被修剪，会呈现在元素框之外。

overflow：hidden 内容会被修剪，并且其余内容是不可见的。

overflow：scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。

overflow：auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。

overflow：inherit 规定应该从父元素继承overflow的属性。

**visibility 属性规定元素是否可见**

visible：默认值。元素是可见的。

hidden：元素是不可见的。

collapse：当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为 "hidden"。

inherit：规定应该从父元素继承 visibility 属性的值。

![](https://gitee.com/kszycyp/blog/raw/master/img/Snipaste_2021-07-09_18-31-35.png)

## 2022联易融提前批前端面经6.30

#### 1、算法题，求二叉搜索树上第k小的数....

## 好未来前端一面面经6.29

#### 1.说说快速[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)怎么实现的？快速[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)是稳定的吗？为什么不稳定，那你可以说一个稳定的[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)吗，怎么实现的？

#### 2.bus事件总线，vue3支持事件总线吗？

#### 3.一根不均匀的绳子，烧完需要一小时，那么让你确定一小时15分钟时间，你需要几根绳子？怎么实现？

3根绳子：第一根从一段点燃，第二根两段点燃，第二根烧完立即第一根的另一端也点燃，这时候过了半个小时，等第一根烧完这时候又过了15分钟，立即第三根绳子两段点燃，第三根绳子烧完则又烧了半个小时。这时候总共烧了30min+15min+30min = 1个半小时。

## 滴滴二面7.9

#### 1.手写reduce方法：

```
原生：
let arr = [1,2,3,4];
arr.reduce((pre,cur)=>{return pre +cur;},0)

手写：
Array.prototype.myReduce = function(fn,value = 0){

	for(let i = 0; i<this.length; i++){
		value = fn(value,this[i]);
	}

	return value;
}

let add = function(a,b){
return a+b;
};
```

#### 2.浏览器的线程问题：

**浏览器是多线程的，js是单线程的**

**Js是单线程的**：

js代码始终在一个线程上执行，此线程被称为js引擎线程，即主线程。可以通过webWorker在后台再创建多子个线程，协助原来的主线程完成工作，子线程完全受主线程控制，且不能操作dom。

**浏览器是多线程的：**

**1**.js引擎线程(js引擎有多个线程，一个主线程，其它的后台配合主线程)
作用：执行js任务(执行js代码，用户输入，网络请求)

**2**.ui渲染线程
作用：渲染页面(js可以操作dom，影响渲染，所以js引擎线程和UI线程是互斥的。js执行时会阻塞页面的渲染。)

**3**.浏览器事件触发线程
作用：控制交互，响应用户

**4**.http请求线程
作用：ajax请求等

**5**.定时触发器线程
作用：setTimeout和setInteval

**6**.事件轮询处理线程
作用：轮询消息队列，event loop

#### 3.三次握手？服务端回应之后没有反应会怎样

TCP设有一个爆活计时器，每次重新接收到客户端请求都会归0，等待下一次客户端发来请求，一般时间设置为2小时。如果两小时还没有收到客户端发来的新的请求，服务器端就会发探测报文，每隔75s发一次，一共发10次，如果仍没有反应，服务器端就会认为客户端出了故障，并关闭连接。

## 京东前端实习一面面经7.9

#### 1.数组和[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)在存储上的区别：

**数组特点是查询快，增删慢**：数组在内存中是一块连续的区域，可以从数组的首地址向后偏移进行数据的查询访问。而对于数组的增删操作，会涉及到原有数组元素的移动。查找的时间复杂度是o(1),增删的时间复杂度是o(n)。

**链表特点是增删快，查询慢：**链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的，链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。

**常用数据结构：**

数组、队列、栈、链表、树、图、堆、hash散列表

#### 2.堆栈区别

**数据结构上：**栈遵循先进后出的原则，而堆是个优先队列，按照优先级进行排序

**操作系统上：**栈内存由编译器自动分配释放，堆内存由程序员手动进行分配释放，若程序员不释放，程序结束时可能由垃圾回收机制回收。

#### 3.排序方法有哪些 ？快排的实现思想、时间复杂度 完善归并排序

**冒泡排序、选择排序、插入排序、希尔排序、归并排序、快排、堆排序、基数排序**

**快排的思想：**一次排序将数据分割成独立的两部分，一部分的所有数据都比另一部分的所有数据都要小，然后在递归的分别对这两个部分进行同样的操作。

快速排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n²) ，

快速排序的空间复杂度取决于递归的深度，所以最好的时候为 O(logn)，最坏的时候为 O(n)；

非稳定排序。

**稳定性**的意思就，是对于相同值来说，相对顺序不能改变。通俗的讲有两个相同的数 A 和 B，在排序之前 A 在 B 的前面，而经过排序之后，B 跑到了 A 的前面，对于这种情况的发生，我们管他叫做排序的不稳定性。

#### 4.对前端工程化的理解

前端工程化就是为了让前端开发能够“自成体系”，个人认为主要应该从**模块化**、**组件化**、**规范化**、**自动化**四个方面思考。

**模块化：**将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。(**WebPack**)

**组件化：**模块化只是在文件层面上，对代码或资源的拆分；而组件化是在设计层面上，对UI（用户界面）的拆分。

**规范化：**规范制定的好坏会直接影响到后期的开发质量。

**自动化：**任何简单机械的重复劳动都应该让机器去完成。

## tplink前端成都一二三面面经7.9

#### 1.算法题：

二叉搜索树原理、二叉搜索树的中序遍历结果、链表怎么判断环、怎么用两个队列实现栈、

找第三大的数、给定数组，不能取相邻的数(包括首尾)，怎么取最大的和

#### 2.智力题：

赛马问题，25 匹马，5 个赛道，最少几次能选出最快的三匹马？  7次

#### 3.秒杀活动怎么优化

**1**.限流，点击提交按钮后按钮置灰，显示为正在排队中，能处理结束或若干秒后，才允许用户点击
**2**.页面静态化，将页面做成静态页面，不经过webserver的处理，直接返回
**3**.CDN分流，将页面放在CDN上，用户刷新页面直接返回，不必惊动服务器
**4**.商品数量显示，使用倒计时，倒计时结束后，使用动画模拟数量减少，此处可能涉及使用长连接，长轮询等方法来保持与后端库存数量的一致(待定)
**5**.秒杀开始前不让用户进入秒杀页面，在开始后，使用动态URL，例如携带随机数的URL，让用户通过按钮点击进入页面

## 同城艺龙一面（80min）6.29

#### 1.移动端如何实现0.5px边框



#### 2.如何解决加载css出现不断闪烁空白问题

样式跳动是指先出现没有样式的html结构，之后样式又突然出现的现象。这主要是应为CSS加载解析太慢导致，可能是CSS被放到html底部去了，也有肯能就是CSS太大了。解决办法利用link标签在文档首部引入css，然后就是尽可能的压缩css文件

补充白屏：

白屏就是指页面内容迟迟没有渲染，而我们知道dom和css的加载和解析构建dom树和css是页面渲染的前提，则主要原因可能是因为js放到了文档头部阻塞文档的加载和解析从而阻塞了页面渲染，亦或是CSS放到了文档底部阻塞了渲染。

#### 3.如何设置localStorage存活一定时间



#### 4.如何实现人为垃圾回收 

delete删除对象属性，对象设置为null

## 字节跳动前端实习面经6.28

#### 1.怎么让对象的一个属性不可被改变

对象的可扩展性：

Object.preventExtensions()不可扩展

Object.seal()不可配置

Object.freeze()不可修改

#### 2.进程和线程的区别，为什么js是单线程的

进程：是cpu分配资源的最小单位；

线程：是cpu调度的最小单位；一个进程可以有多个线程

JS之所以是单线程的这和其用途有关，其作用主要是实现用户和浏览器的交互，以及操作dom，这决定了其是单线程的。举个例子，如果JS被设计为多线程的，一个线程要修改一个dom，而另一个线程要删除这个dom，这时浏览器就不会知道怎么办，所以为了避免这些同步问题，js被设计为单线程了。

#### 3.箭头函数 （x）=> x; (x)=>(x); (x) =>({x}) 输入x=1；输出分别是什么

let f = （x）=>  x; 等价于function f(x) {return x } 等价于 let f = function(x){return x}

1   1    {x:1}

#### 4.路由的两种模式，怎么体现hash值的变化

#### 5.算法题

**手写promise.any**

**多叉树的最大深度**

**数组的topk大数字，堆排序**

## 字节两个部门，六轮面试6.28

#### 1.看代码this 指向谁，如何更改 this 的指向

```
// 非原题 非原题 非原题
const o1 = {
    text: 'o1',
    fn: function() {
        return this.text;
    }
}
const o2 = {
    text: 'o2',
    fn: o1.fn
}
console.log(o2.fn());  
o2
//==================================
const o1 = {
    text: 'o1',
    fn: function() {
        return this.text;
    }
}
const o2 = {
    text: 'o2',
    fn: o1.fn()
}
console.log(o2.fn); 
o1
```

#### 2.项目：

讲讲项目，说说你的亮点

- 亮点，性能优化吧，怎么测量的，怎么优化的，优化前后的对比
- Network, Lighthouse, Performace, Memory, Webpack、网络
- 面试官也会提出一些问题，问我怎么优化，原理是什么

#### 3.二分查找

#### 4.异步任务调度器

#### 5.服务器端渲染SSR

有利于Seo、降低了客户端的资源损耗和耗时、

不利于前后端分离、加重了服务器端的负担

#### 6.Session了解吗，JWT

登录鉴权简单来说就是验证用户身份，看用户是否有权限去访问某些资源。

常用的鉴权方式：

**cookie+session**

**token**

**JWT（JSON Web Token）:**

JWT由三部分构成：base64加密的头部 + base64加密的载荷 + 

用头部声明的加密算法，以及只有服务器端知道的私钥对前两段加密后的信息

大体流程就是，客户端登录，服务器端生成jwt用于标识用户身份发给客户端，客户端在向服务器端发送信息时携带JWT，服务器端验证发过来的JWT，（具体的验证无非就是对前两段进行如上介绍的加密，看和第三段是否一样，如果不一样那就说明验证不通过）验证身份通过服务器端在向客户端发送信息。

#### 7.http和https

HTTPS中客户端如何验证服务器端发过来的证书：

浏览器中内置信任的根证书，就看web服务器的证书是不是这些信任根或者是信任根的二级证书机构发的。然后就是看web服务器证书是否有效，是否被吊销了。

Https中非对称加密安全速度慢可以用来传递对称加密所用的密钥

对称加密用于通信，表示服务器端身份可以利用CA证书。

#### 8.强缓存与协商缓存

强缓存对于经常不变的比较大的资源，如果缓存的资源发生变化了，可以指定no-catch字段让服务器端处理一下。

#### 9.模块热替换

允许在运行时更新各种模块，而无需对网页进行完全刷新

webpack-dev-server

#### 10.webpack相关

loader加载器主要是用来转换某些类型的模块，让webpack能对其进行正常的打包操作

pluging插件是扩展器用于扩展webpack默写方面的功能。

#### 11.IEEE754

是一种二进制的浮点数表示法，JS采用的就是这种浮点数表示法

#### 12.TCP的流量控制以及拥塞控制

## 蔚来前端面经凉7.11

#### 1.手写Promise...

#### 2.Rem，自适应布局

Rem布局，可以说是弹性布局，将元素大小与根元素绑定起来，实现元素的统一，便于页面的整体缩放。

自适应布局，同一个站点有多个版本分别适配不同的终端设备，具体的适配方式可以根据媒体查询

响应式布局，同一个站点可以兼容多个不同的终端设备，而不用给他们设计不同的版本。

## 蔚来前端一二三连环面面经7.10

#### 1.项目：element-ui，说下它里面的表单校验是怎么使用的

#### 2.element-ui的过程中有没有发现它的什么问题或是不足的地方

#### 3.Vuex是永久保存的吗？（不是）想要永久保存怎么办？（回答用localStorage）但是localStorage不是双向数据绑定的怎么解决？（我说将Vuex和localStorage结合使用，同步它们的数据）

#### 4.雪花飘落实现思路

#### 5.在项目的过程中遇到过哪些难点？怎么解决的？

#### 6.有看过`Promise`的[源码](https://www.nowcoder.com/jump/super-jump/word?word=源码)吗？说下它是怎样实现的

#### 7.算法题：爬楼梯、全排列 

#### 8.401身份验证有误，403你没有权限访问指定资源

#### 9.手写发布订阅模式：

注意点：每个事件都是订阅中心events的属性，属性值是是一个数组，数组存放了关于这个事件的全部回调函数。

```
function EventHub() {
    this.events = {}
}

EventHub.prototype.listen = function (event, callback) {
    if (this.events.hasOwnProperty(event)) {
        this.events[event].push(callback)
    } else {
        this.events[event] = [callback]
    }
}

EventHub.prototype.emit = function (event, ...args) {
    if (this.events.hasOwnProperty(event)) {
        this.events[event].forEach(element => {
            element.call(this, ...args)
        })
    } else throw 'Error'
}

```

## 蔚来提前批前端一面面经7.10

#### 1.内存的生命周期：

内存分配：当我们申明变量、函数、对象的时候，系统会自动为他 们分配内存

内存使用：即读写内存，也就是使用变量、函数等

内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存

#### 2.算法：环形链表

#### 3.event.target 和event.currentTarget区别

event.target代表的是触发事件的元素，

event.currentTarget代表的是那个绑定了事件处理函数的元素

## 蔚来前端一面 凉经7.10

<img src="https://gitee.com/chenyipeng9/blog/raw/master/img/Snipaste_2021-07-12_13-14-41.png" style="zoom:67%;" />

#### 1.axios用过吗？说说都有几种参数？请求拦截器用过吗？可以处理什么问题，axios返回的是一个什么对象？

#### 2.margin相关的问题 外边距合并、塌陷与解决

第一种，相邻兄弟元素之间上下外边距的塌陷，可以给其中一个元素设置BFC

第二种，父元素上外边距和子元素的上外边距，则可以给父元素设置border-top、padding-top，或是给父元素设置BFC

第三种，父元素下外边距和子元素的下外边距，则可以给父元素设置border-bottom、padding-bottom，或是给父元素设置BFC

第四种，元素自身上下外边距塌陷，可以给元素设置边框、内边距或高度来加以解决

## 字节抖音前端实习一面凉经7.10

### 1.下面这个str1，str2，str3如果用===来判断，是true还是false？

```
var str1 = 'abc';
var str2 = String('abc')
var str3 = new String('abc')

str1 === str2  true    
str1 === str3  false
```

包装对象：区分字符串值和字符串对象、布尔值和布尔对象、数值和数值对象

new Number（）、new String（）、new Boolen（）创建包装对象，获取的是对象

Number（）、 String（）、 Boolen（）进行显示的类型转换，获取的是值

## 字节前端面经，多面几次就过了（bushi 7.12

#### 1.怎么把html页面转换成图片？

html2canvas库应该是可以将html转换成图片

#### 2.常见的语义化标签，以及那些是行内元素，那些是块级元素？

head、nav、section、article、footer、aside、strong、em

行内元素：head、strong、em

块级元素：nav、section、article、footer、aside

## 众安保险 前端一面面经

#### 1.前端规划

## 百度提前批前端面经

#### 1.谈谈vue：

vue是一个渐进式JS框架，就是说vue有很多功能，你需要哪一部分，就可以使用哪一部分到你的项目中。vue的核心特性是数据双向绑定和组件化。除此之外，vue配套的工具库还有vuex和vue-router，前者做状态管理，后者做路由管理。

#### 2.输出100以下随机数

## 中望软件提前批一面面经7.13

#### 1.Vue封装组件？

#### 2.git push向远程仓库推送内容，git pull 向远程仓库拉取内容

#### 3.传统的URL，以及restful形式的url

‘/abc?id=123’    服务器端监听路由'/abc'对应服务器端拿取通过req.query.id

'/abc/123'      服务器端监听路由‘/abc/:id’  对应服务器端拿取通过req.params.id

#### 4.指针和引用的区别？

**指针:**的是某块内存的**地址**，通过这个地址，我们可以寻址到这块内存

**引用:**是一个变量的**别名**，例如我们给小明起了个外号：明明，那我们说明明的时候，就是说小明



## react前端工程师校招一面面经 7.13

#### 1.看代码：

```
setTimeout(() => {
    console.log('timeout')
}, 0);
const p = new Promise((resolve) => {
    resolve(100);
    console.log('promise constructor');
}).then(() => {
    console.log('prpmise then 1');
    Promise.resolve().then(() => {
        console.log('nested promise then');
    });
}).then(() => {
    console.log('Promise then 2');
})
console.log('normal execution');

promise constructor
normal execution
prpmise then 1
nested promise then
Promise then 2
timeout
```

#### 2.JS语言的看法：

动态语言，需要有解释器翻译成中间代码而后在转成机器语言；

JS是单线程的，主要就是用于浏览器环境中进行页面动态效果的展示；

相比于其他JAVA这样的面向对象的编程语言，自身还是存在相当一大部分问题的，但是目前还是不断的在发展，比如ES6、TS等。总的来说JS未来的发展是更加严谨、安全、效率更高。

## 2021同花顺秋招提前批前端一面面经

#### 1.css实现列表单数列红色，偶数列蓝色：

## 端点网络科技前端一面7.14

#### 1.VUE中数据变化但是页面还未渲染怎么办

Vue是异步渲染也就是说异步的进行DOM的更新，数据的变动不会立即反映到页面上，而是会等当前这一轮事件循环中所有数据变动结束，才会去进行一次页面的渲染。所以你进行某个数据变动后去访问这个数据，其实还是获取更新前的值，你这个时候就可以用$nextTicket他会在dom更新完成之后触发，也就是说你可以通过其回调函数，拿到更新之后的数据的值。

#### 2.父组件和子组件生命周期钩子函数执行顺序

**子的生命周期都会被先结束，父的才结束。先由父到子，再从子到父。**

**加载渲染过程：**父beforeCreate--》父created----》父beforeMount---》子beforeCreate---》子created---》子beforeMount---》子mounted---》父mounted

**子组件更新过程：**父beforeUpdate--》子beforeUpdate---》子updated---》父updated

**父组件更新过程:**  父beforeUpdate  ---》 父updated

**销毁过程：** 父beforeDestory  ---》 子beforeDestory  ---》 子destoryed  ---》父destoryed

#### 3.vue的响应式原理，v-model的原理

Vue响应式就是数据影响视图，视图影响数据，即实现视图View和数据model的同步更新。通俗来说就是双向数据绑定，具体双向数据绑定的实现是由数据劫持和发布订阅相结合实现的。Vue2.中数据劫持操作主要是由Object.defineProperty()来实现，Vue3中数据劫持操作则是由ES6的Proxey实现。

视图影响数据：直接绑定某个控件的监听事件，比如input元素绑定监听事件

数据影响视图：数据劫持+发布订阅，对数据进行劫持，发现其变化就通知视图做出相应改变

v-model就实现双向数据绑定的原理

#### 4.axios怎么封装的，优点，请求拦截有添加吗

## 百度前端一面面经7.14

#### 1.float实现自适应变化

父元素，子元素宽度width设置width:100%

#### 2.正则表达式：字符串转驼峰式(代码)

```
str.replace(/\w/g,function(eord){return word.slice(0,1).toLowerCase() + word.slice(1)})
```

#### 3.vuex和bus的区别(X)

## 字节前端一面面经（50min）7.14  

#### 1.说说JS有什么特点和优缺点

动态语言(弱类型的)：其动态性就主要体现在是事件驱动的脚本语言，不需要经过web服务器就可以对用户的输入做出响应；解释性语言，是在程序运行过程中逐行进行解释的；跨平台性好，不依赖于操作系统，只需要浏览器的支持就可以了。主要是因为解释性原因并不是直接到机器语言，而是先翻译成中间代码（还是文本形式的代码），然后由解释器将其解释成相应的机器语言并加以执行，所以有解释器就可以了。相较于编译型语言，直接将源代码编译成相应的机器代码，然后直接执行，但是不同操作系统识别二进制的方式不同，编译后的机器码不一定能够在所有平台上运行，所以跨平台性不好。

**解释型语言的源代码不是直接翻译成机器语言**，而是首先翻译成中间代码，然后再由解释器对中间代码进行解释运行。

```
解释型语言每次在运行时都需要实时的去翻译中间代码然后执行翻译出的机器代码，所以执行效率低下．

解释型语言严重依赖于解释器的类型，解释器速度快，那么执行速度就会快一点．

因为不需要进行预先编译，所以是以文本的方式存储程序代码，跨平台能力好
```

**编译型语言是直接经过编译处理**，把源代码直接翻译成机器代码，再由机器运行机器码．

```
跨平台能力: 因操作系统识别二进制的方式不同，所以经过编译后得到的机器码不一定能够在所有平台上运行，而解释型语言不同，只需要在系统配置一个解释器，程序即可兼容各个平台．
```

#### 2.上下左右居中除了flex和定位还有哪些方法

行内元素

line-height，vertical-align：middle，text-align：center

```
.container {
            background: rgba(0, 0, 0, 0.5);
            width: 300px;
            height: 300px;
            text-align: center;
            line-height: 300px;
        }
        
        .box {
            width: 100px;
            height: 100px;
            background-color: pink;
            display: inline-block;
            vertical-align: middle;
        }
```

#### 3.css变量

属性前面加--就代表变量，比如`body`选择器里面声明了两个变量：`--foo`和`--bar`。

```
body {
  --foo: #7F583F;
  --bar: #F7EFD2;
}
```

`var()`函数用于读取变量，如果该变量不存在，就会使用第二个参数的默认值。

```
color: var(--foo, #7F583F);
```

**注意，变量值只能用作属性值，不能用作属性名。**

如果变量值是数值，不能与数值单位直接连用。

```
.foo {
  --gap: 20;
  /* 无效 */
  margin-top: var(--gap)px;
}

.foo {
  --gap: 20;
  margin-top: calc(var(--gap) * 1px);
}
```

#### 算法题：给出给定字符串的回文子串个数（单个字符也算回文）

## 阿里巴巴CBU技术部 前端实习一面凉经

#### 1.算法题：获取嵌套数组的深度

```
function findDeep(input){
	let num = [], flag = false;
	
	for(let i = 0; i<input.length; i++){
		let obj = input[i];
		if(Array.isArray(obj)){
			flag = true;
			num.push(findDeep(input[i]));
		}
	}
	
	if(flag){
		return Math.max.apply(null,num) + 1;
	}else{
		return 1;
	}
}
```



#### 2.CSS画一个边长小于1px的线段或div怎么实现

div指定高度1px，scaleY(0.5)缩小一半

## 阿里国际事业部 前端一面面经

#### 1.http2中的长连接相比于http1中手动指定keep-alive的优势

**注意：**

长连接和短连接是指持续连接和非持续连接

这和即时通信中的长轮询和短轮询不是一回事。

http1.0默认采用非持续连接，你每发一次请求都要事先建立一个TCP连接，这就造成了资源的极大浪费，

即http1.0中持续连接是默认关闭的，需要在http头中加入connection：Keep-Alive才能启用

http1.1开始包括http2.0都采用的持续连接，即多个http请求复用同一个TCP连接

Http1.1中默认启用的，需要在http头中加入connection：close才能关闭

#### 2.node的中间件用过吗 答了一个文件上传中间件、中间件的实现原理

**node中间件**本质上就是在进入具体的业务处理之前，先让**特定过滤器**处理。如下图所示:

<img src="https://gitee.com/chenyipeng9/blog/raw/master/img/v2-a9ae415552231968cb185960a9e9ec6e_r.jpg" style="zoom:50%;" />

```
const middleware = (req, res, next) => {
  // 请求处理逻辑
  next()
}
```

#### 3.###项目优化中Gizp压缩是什么，怎么做的，压缩的传输格式你觉得是什么，为什么

#### 4.知道哪些现在的前端新趋势吗 答了vite和跨平台web

TypeScript接管前端、小程序、跨端开发(跨端处于且将长期处于多方案并存且不断变化的状态)、前端工程化

跨端开发：理解就是在不同的终端都能使用Write once, run everywhere。

## 端点 前端一面面经 7.15

#### 1.promise.all出现一个失败怎么继续？

包装的多个promise实例，都在catch中抓住错误并return一个触发resolve的promise

```
const  p1 =  new Promise(resolve => {
    const a =b;
    resolve(a);
}).catch(()=>{
    return Promise.resolve('aaab')
});
const  p2 =  new Promise(resolve => {
    const a =1;
    return resolve(a);
}).catch(()=>{
    return Promise.resolve('aaa')
});
 
 
Promise.all([p1,p2]).then((data)=>{
    console.log('then 成功',data);
}).catch((err)=>{
    console.log('333');
    console.log('errr',err);
})

结果： then 成功 ['aaab',1]
```

## shopee 前端深圳一、二面面经 7.16

#### 1.padding继承父级宽度:

孩子宽度默认继承父亲宽度100%，孩子高度则由孩子自己的内容自行撑开，

你没给孩子设置宽度，则padding设置无效，你给孩子自行设置了宽度，padding才有效

而且你孩子指定padding：inherit，只是继承了父亲的padding情况

#### 2.flux：

flux是一种软件架构，和MVC架构是同一类东西，但是更加简单清晰。

```
View： 视图层
Action（动作）：视图层发出的消息（比如mouseClick）
Dispatcher（派发器）：用来接收Actions、执行回调函数
Store（数据层）：用来存放应用的状态，一旦发生变动，就提醒Views要更新页面

flux最大特点就是单向流动：
用户访问 View
View 发出用户的 Action
Dispatcher 收到 Action，要求 Store 进行相应的更新
Store 更新后，发出一个"change"事件
View 收到"change"事件后，更新页面

MVC在实际使用时并不是你理论分析的时候的1对1的关系，现实中往往是多视图、多模型，更严重的是视图与模型之间的多对多的关系，为此，视图和模型之间的关系就比较乱，这样也就会造成很多问题。所以flux的软件架构被提出来，解决MVC存在的不足。
(flux中没有一个职责明确的controller。事实上，Flux中存在一个controller-view的角色，但它的职责是将view和store进行绑定，并没有传统MVC中controller需要承担的复杂逻辑。)
```

![](https://gitee.com/chenyipeng9/blog/raw/master/img/bg2016011503.png)

<img src="https://gitee.com/chenyipeng9/blog/raw/master/img/20190310154752676.jpg" style="zoom: 67%;" />

#### 3.must-revalidate、及catch-control属性

```
在 HTTP 客户端（浏览器或者缓存服务器）上，如果某个 URL 对应的缓存过期了，客户端会再次向该 URL 发送一个条件请求（带有If-Modified-Since/If-None-Match请求头），如果服务端（缓存服务器或者源站）返回的状态码是 304（没有响应体），则客户端会根据该304响应所包含的一些响应头（Date、Last-Modified、Cache-Control等）重新计算出这条缓存的过期时间
```

```
浏览器：资源请求直接发起方。
源服务器：资源实际提供方。
缓存服务器：在浏览器、源服务器之间架设的中间服务器，由它代替浏览器，向源服务器发起资源请求；
缓存服务器作用如下。缓存服务器不是必须的，浏览器也可与源服务器直接通信。
```

**Catch-control可以由多个字段合成，主要包括如下：**

**max-age** 指定一个时间长度，在这个时间段内缓存是有效的，单位是s

**s-maxage** 同 max-age，覆盖 max-age

**public** 表明响应可以被任何对象（发送请求的客户端、代理服务器等等）缓存

**private** 表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的，不能被代理服务器缓存

**no-store** 禁止缓存，每次请求都要向服务器重新获取数据。

**no-cache** 告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验。

**must-revalidate**告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。(但实际上这个字段在浏览器端几乎没有任何作用，在缓存服务器上有一点点的作用)

#### 4.常见浏览器的CSS私有前缀

```
 Gecho   内核 （firefox,flock 等）    -moz
 webkit  内核 （safari,chrome 等）   -webkit
 opera   内核 （opera 浏览器）        -o
 trident 内核 （ie 浏览器）           -ms
```

#### 5.算法：

```
返回排序后前n个元素

判断一棵树的对称性(层序遍历判断)

力扣415.字符串相加
```

#### 6.浏览器多进程架构

主要是为了保证浏览器的健壮性以及稳定性，避免一个环节出问题整个浏览器都崩溃了

最新的 Chrome 浏览器包括：

**1 个浏览器（Browser）主进程、**

**1 个 GPU 进程、**

**1 个网络（NetWork）进程、**

**多个渲染进程和**

**多个插件进程**

<img src="https://gitee.com/chenyipeng9/blog/raw/master/img/2020012316114580.jpeg" style="zoom: 50%;" />

#### 7.缓存存储位置，Cache文件夹

Application/catch

HTML5离线缓存(离线存储)：

缓存清单文件mainfest.appach

html标签中mainfest属性引入

catch：需要缓存的资源、network不需要缓存的区域、

fallback找不到资源就用指定资源替换

只要缓存清单文件发生变动就会更新缓存

#### 8.Etag生成原理

```
ETag生成靠以下几种因子：
文件的i-node编号，此i-node非彼iNode。
文件最后修改时间
文件大小
生成Etag的时候，使用其中一种或几种因子，而后用散列函数加以生成
```

#### 9.同源网站和同站点网站的cookie设置

同源网站不受跨域问题的影响，发送请求时会自动携带上cookie

同站点，或者说一个大域多个子域的跨域问题，可以在子域中设置document.domin=根域名从而放宽同源政策的限制，实现跨域。

#### 10.公司内部的单点登录系统的原理



#### 11.css的预加载属性

|                                                              | preload                                         | prefetch                                             |
| ------------------------------------------------------------ | ----------------------------------------------- | ---------------------------------------------------- |
| 语法                                                         | <link rel="preload" href="bg-image-narrow.png"> | <link rel="prefetch" href="bg-image--0narrow.png" /> |
| 加载时间                                                     | 立即加载                                        | 浏览器闲置的时候才会加载（一般而言）                 |
| 用户正在登陆页面，登陆成功之后会跳转到首页。我是否可以在登陆页面就去请求首页的资源呢？ | 用户从A页面进入B页面，preload的会失效           | 而prefetch的内容可以在B页面使用。                    |

#### 12.弱引用的具体场景

1.DOM 节点作为键名，触发事件更新状态作为其键值，

一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。

2.用于部署私有属性

(内部属性`_counter`和`_action`，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。)

#### 13.代码：Promise.all 和 race 实现

## 字节教育前端实习一面面经 7-18附

#### 1.格式转换，data转换成result形式：

```
const data = [
    { id: 10, parentId: 0, text: "一级菜单-1" }, 
    { id: 20, parentId: 0, text: "一级菜单-2" },
    { id: 30, parentId: 20, text: "二级菜单-3" },
    { id: 25, parentId: 30, text: "三级菜单-25" },
    { id: 35, parentId: 30, text: "三级菜单-35" }
];

let result = [
  {
    id: 10,
    text: '一级菜单-1',
    parentId: 0
  },
  {
    id: 20,
    text: '一级菜单-2',
    parentId: 0,
    children: [
      {
        id: 10,
        text: '一级菜单-3',
        parentId: 20,
        children: [...]
      }
    ]
  }
];
```

```
function conver(data) {
    data.sort((a, b) => a.parentId - b.parentId);
    for (let i = data.length - 1; i>= 0; i--) {
        for (let j = i - 1; j >= 0; j--) {
            if (findParent(data[i], data[j])) {
                data.slice(i, 1);
                break;
            }
        }
    }
    return data;
    function findParent(a, b) {
        if (a.parentId == b.id) {
            b.children = b.children || [];
            b.child.push({...a});
            return true;
        }
        return false;
    }
}
```

#### 2.GET 和POST请求到底有什么区别：

```
get是向服务器端请求数据常与缓存结合使用，post是向服务器端提交数据一般不会结合缓存使用

get的请求参数放在URL地址中，而post的请求参数放在报文主体中，所以post请求相对安全一点

get的请求参数长度是有限的的这主要是因为浏览器客户端和服务器端对url地址的长度进行的限制，而不是http协议本身的限制，而post请求就没有这样的问题。

补充1：浏览器在回退时，get 不会重新请求，但是post会重新请求。【重要】

补充2：get请求的参数，会报保留在浏览器的历史记录里，而post不会。做业务时要注意。为了防止CSRF攻击，很多公司把get统一改成了post。
```

#### 3.Proxy 在 ES2015 规范中被正式加入，它有以下几个优势点：

```
1.针对整个对象，而不是对象的某个属性，所以也就不需要对 keys 进行遍历。也就是说可以对整个对象进行拦截，而不是像Object.defineProperty那样只能针对对象的某个属性，从而需要遍历对象的整个属性。

2.proxy的第二个参数，是所要进行的拦截操作，相较于Object.defineProperty而言要更加丰富。
```

#### 4.箭头函数可以使用call/apply/bind吗

```

箭头函数对象通过原型链从Function原型上继承了call/apply/bind函数。箭头函数没有prototype，但是有proto，调用call/apply/bind时会顺着__proto找到父类（也就是Function）原型上的call/apply/bind。箭头函数call/apply/bind没有效，箭头函数内部this被一个在定义时外部词法环境声明的对象this指针代理了，因此没什么作用。
```

#### 5.setTimeout不准时，怎么实现一个前端1s倒计时计数，相对准时（口述）

思路：用0.1s定时器计时，利用Date计算剩下的时间，转换成秒数（整数），监听秒数改变进行变换

#### 6.补全代码：

```
class Queue{
    constructor() {
        this.queue = [];
        this.timer = [];
        this.startTime = 0;
    }
    task(time, fn) {
        this.startTime += time;
        this.queue.push([fn, this.startTime]);
        return this;
    }
    start() {
        for (let i = 0; i < this.queue.length; i++) {
            this.timer[i] = setTimeout(this.queue[i][0],this.queue[i][1]);
        }
    }
    stop() {
        for (let i = 0; i < this.timer.length; i++) {
            clearTimeout(this.timer[i]);
        }
    }
}

const q = new Queue();
q.task(1000, () => {
    console.log(1)
})
.task(2000, () => {
    console.log(2)
})
.task(1000, () => {
    console.log(3)
})
.start()

q.stop(); // 可以随时终止任务
```

#### 7.数字转成汉字

存在问题，超过5位就不正常了

12345 -> 一万二千三百四十五

1234500 -> 一undefined二undefined三万四千五百

```
function revert(num) {
    let numbers = ['零', '一', '二', '三', '四', '五', '六', '七', '八', '九'];
    let counts = ['十', '百', '千', '万'];
    let arr = [];
    while (num) {
        arr.push(num % 10);
        num = Math.floor(num / 10);
    }
    // 这部分主要是将数值拆开放到数组中，便于后续进行遍历组合
    // 123  [3,2,1]
    // console.log(arr);
    let res = "";
    for (let i = arr.length - 1; i >= 0; i--) {
        if (arr[i] !== 0) {
            // 这一部分主要是来处理像1002中2前面的0
            // 很多个0，只在字符串中加入一个0
            if (arr[i + 1] === 0) {
                res += numbers[0];
            }
            res += numbers[arr[i]];
            if (i >= 1) {
                res += counts[i - 1];
            }
        }
    }
    return res;
}
```

## 字节data前端一面面经:

#### 1.手写数组reduce方法、利用reduce实现forEach、map、filter

#### 2.算法：

最长子序列，有效的括号，合并两个排序链表。

#### 3.setTimeout,setInterval,requestAnimationFrame的区别

**setTimeout**、多久后往事件队列中加入回调函数

**setInterval**、每隔多长时间往事件队列中加入回调函数

**requestAnimationFrame：**

首先知道，所谓动画就是浏览器以一定的刷新频率，去一帧一帧的渲染，由于CSS动画指定渲染间隔，以及渲染的开始，所以用户体验好。但是，其存在兼容性问题，且对于控制方面比较强的动画，比如滚动就效果不太好。

所以JS动画补足了CSS存在的小问题。

一般是采用定时器setTimeout,setInterval去以指定的时间间隔模拟动画实现，但是JS引擎单线程而且事件循环的机制使得有时候并不能按时执行回调进行动画帧渲染。而requestAnimationFrame，作为Html5新增的API，其适应浏览器的刷新频率，且是在不同于JS线程的GUI线程上执行，然后就是适应浏览器的刷新间隔进行回调函数的执行，所以动画渲染方面效果比较好。

#### 4.函数柯里化：

#### 5.可怕：

<img src="https://gitee.com/chenyipeng9/blog/raw/master/img/Snipaste_2021-07-20_10-19-51.png" style="zoom:67%;" />

## 字节前端二面面经（50min）

#### 1.TCP粘包问题。

本质和传输层的TCP协议没有关系，主要是因为应用层自己没有处理好数据格式。TCP本来就是基于字节流的协议，我会把你的报文数据变成字节流进行传输，但是不一定就是按照你指定的报文边界进行相应处理，可能一个TCP包里面含有多个报文的字节流，所以你使用我TCP，你要自己搞定字节流解析，所以这个问题其实就是“如何设计应用层协议的问题”。可以考虑设计一个带有包头的应用层报文结构，包头定长，以特定的标志开头等。

```
1.由于tcp是面向流的协议，不会按照应用开发者的期望保持send输入数据的边界，导致接收侧有可能一下子收到多个应用层报文，需要应用开发者自己分开，

2.用户数据被tcp发出去的时候，存在多个小尺寸数据被封装在一个tcp报文中发出去的可能性。这种“粘”不是接收侧的效果，而是由于Nagle算法（或者TCP_CORK）的存在，在发送的时候，就把应用开发者多次send的数据，“粘”在一个tcp报文里面发出去了，于是，先被send的数据可能需要等待一段时间，才能跟后面被send的数据一起组成报文发出去

1.人家本身就是个面向流的协议，如果你要用它传输数据报（datagram），必然要自己实现stream2datagram的过程。这不叫解决问题，这叫实现功能。

第一种“粘包”，靠设计一个带包头的应用层报文结构就能解决。包头定长，以特定标志开头，里带着负载长度，这样接收侧只要以定长尝试读取包头，再按照包头里的负载长度读取负载就行了，多出来的数据都留在缓冲区里即可。

第二种“粘包”，设置TCP_NODELAY就能屏蔽Nagle算法，但你最好确定自己知道自己在干什么。
```

#### 2.看代码，看不懂

```
// ./a.js
let count = 1;

setCount = () => {
count++;
}

setTimeout(() => {
console.log('a', count)
}, 1000);

module.exports = {
count,
setCount
}

//b.js
const obj = require('./a.js');

// 你这个count改的是setCount上层作用域的count
// 上层作用域中count为2了，并不影响你对象中的count属性的1
// 上层作用域中的count通过异步a反映出来了
obj.setCount();

//导出一个对象，对象里面的count属性obj.count为2
//就没有变动
console.log('b', obj.count)

setTimeout(() => {
console.log('b next', obj.count);
}, 2000);

b 1 
a 2 
b next 1 
```

```
const vm = new Vue({
template: '#example',
data() {
return {
message: '123'
}
}
})

vm.message = 'hello world';
console.log(vm.$el.innerText === 'hello world');

false，修改数据并不能立即获取到，还是之前的数据，$nextTick 会在dom更新完成后触发，在其回调函数中可以获取更新后的数据。
```

```
几十亿量级的数字数据，怎么去找是否存在某个数。（开放题，不过后面提示了bitmap和布隆过滤）
```

## 京东前端一面凉经

#### 1.ajax同步还是异步？如果变成同步应该怎么办？

```
const xhr = new xmlHttpRequest();
xhr.open()第一个参数建立请求的方式、第二个url地址，第三个指定false将ajax变为同步，send会阻塞直到请求完成，(意思就是没有从服务器端拿到请求数据就一直卡在这)。
xhr.send()
xhr.onload = function(){xhr.responseText}

readyStateChange 老版事件监听 readyState为3则接收到了请求数据了

```

## 字节抖音前端秋招提前批一面面经

```
1. 项目中的亮点?
2. axios拦截器的原理?
3. 就是在node和浏览器端都用axios发请求 axios怎么知道是哪个端用的？
浏览器端的话axios底层用XHR node好像是用http发
```

#### 3.3D渲染要创建一个新的图层？

#### 4.cookie跨域要怎么做

```
cookie不能跨域，其domin和path属性结合起来，指定那些url可以访问cookie，就比如单点登录系统，a.taoBao.com
b.taoBao.com
将cookie的domin设置为taoBao.com
cookie的path设置为/
则上述两个域名站点就可以共享cookie了
```

#### 5.cros跨域资源共享设置

```
Access-control-allow-origin：*  //指定那些域可以跨域访问我这个域
Access-control-allow-method：   //指定跨域请求的方式
```

#### 6.js中一个任务崩了，怎么做才能不影响其他的任务？

```
捕获错误并处理，
ES6：Promise.try().catch()可以捕获同步错误也可以捕获异步错误，此外其如果包裹同步代码就同步执行，异步代码就异步执行。
const f = () => console.log('now');
Promise.try(f);
console.log('next');
```

#### 7.浏览器的不同tab间是线程还是进程

```
浏览器中打开一个网页相当于新起了一个进程（进程内都有自己的线程），当然，浏览器出于自己的优化，有时会将多个进程合并成同一个进程（比如打开多个空白页）。
```

#### 8.看代码promise同步异步代码执行问题

```
console.log(1);

new Promise(resolve => {
    resolve(console.log(3))
    console.log(5)
}).then(() => {
    console.log(4)
})

console.log(2);

13524
promise的参数是个函数，函数的参数resolve、reject也是个函数，你这个resolve啥的只是负责传递状态数据，如果里面包含同步代码那还是同步执行的，也就是说只有then、catch方法里的才是异步代码。 resolve(console.log(3))里面的console.log(3)还是同步的，此外你整个回调函数中的同步代码就是同步的，异步的就是异步的如console.log(5)还是同步的。
```

## 字节抖音部门前端一面凉经 7.21 

#### 1.对帖子的评论可能涉及到多个操作，如添加评论，对应的评论数加1，对应的热度与分数增加...如何保证这些事件都能正确完成？

 (我[项目](https://www.nowcoder.com/jump/super-jump/word?word=项目)做了个简单论坛系统，我回答了用事务，面试官不太满意，提到了用消息队列)

#### 2.对于一个搜索框，如何实时获取后端数据？从[前端](https://www.nowcoder.com/jump/super-jump/word?word=前端)的角度回答

（他说通过防抖和节流，不太了解[前端](https://www.nowcoder.com/jump/super-jump/word?word=前端)。。）

## 百度前端提前批一面 7.21

#### 1.快排的时间和空间复杂度：

快排的思想就是将数据分成两部分，使左边的都小于右边的。然后对这两边接着递归下去，从而进行排序。

(找个分解值确定他应该在什么位置，使他左边的数据都小于他右边的数据)所以

时间复杂度包括每次划分的就是取值，即为o(n)，然后你划分的情况决定了递归的次数，如果刚好是将数据给对半分了，那我在递归logn次就行了，所以最好情况下总的时间复杂度就是o(nlogn)。最坏情况下就是你分的两边的数据，全在一边那就要递归n次，则最坏情况下的总的时间复杂度就是o(n^2)。

空间复杂度就根据你递归的次数有关，则根据上述分析：最好的情况下递归logn次则空间复杂度为o(logn),最坏的情况下递归n次则空间复杂度就是o(n).

## 字节火山前端提前批面经 7.21

#### 1.tcp的流量控制，拥塞窗口大小怎么变化的？具体[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)，数学模型。窗口初始值为什么是2？拥塞后，会降为多大？

## 北京虾皮 提前批 前端一面凉 7.21

#### 1.渲染是在宏任务完成之后还是微任务完成之后

```
 Call Stack清空
 执行当前的微任务
 尝试DOM渲染
 触发Event Loop
```

1. 微任务：DOM渲染前执行，微任务是ES6语法规定
2. 宏任务：DOM渲染后触发，由浏览器规定（Web APIs）

## 京东前端一面面经 7.21

#### 1.vh vw rem em

rem和根元素的大小有关，

设置根元素大小就是html元素中设置font-size，没设置就是默认的16px，即1rem=16px

em和父元素的大小有关，

先看自己有没有设置font-size，没有就一层层往上

vh视口高度的1%，vw视口宽度的1%

## 字节跳动 前端 一二三面 + HR面（已意向）

#### 1.看代码确定输出

```
for(var i = 0; i < 5; i++) {
    let out = i;
    setTimeout(function()  {
        console.log(out);
    }, 2000)
}
// 0 1 2 3 4 
for(var i = 0; i < 5; i++) {
    setTimeout(function(){
        console.log(i);
    }, 2000)
}
//  5 5 5 5 5 
for(let i = 0; i < 5; i++) {
    setTimeout(function(){
        console.log(i);
    }, 2000)
}
// 0 1 2 3 4 

for(var i = 0; i<5 ;i++){
	(function(a){
		setTimeout(function(){console.log(a)},2000)
	})(i)
}
```

#### 2.算法题

54. 螺旋矩阵、42. 接雨水、200. 岛屿数量

#### 3.cookie相关

服务器端通过set-cookie相关字段可以进行设置，修改，删除

客户端通过document.cookie进行查询，设置（就是给他赋值），更新（同一个属性附上新的值），

删除（置为空）

cookie中的secure字段，指定为true则只有在https情况下cookie才能发往服务器端，

HttpOnly属性、使得JS脚本无法读取到cookie信息，可以有效防止XSS攻击

secure和httpOnly的区别，前者是cookie信息在传递过程中安全，后者是在获取到cookie的情况下，防止进行XSS攻击

max-age、name、value、domain、path

#### 4.谈一谈高阶函数

操作函数的函数，接收一个或多个函数作为参数，并返回一个函数

#### 5.说一下vue数据响应中对数组的处理

变成响应式的，数组中数据变动，也会响应式的变更用到数据的视图。concat、slice创建新数组。

## 京东前端一面面经

#### 1.项目

```
项目中的css大部分都是自己写的还是用的框架？
项目中有遇到什么困难，比如技术问题，沟通情况等等？怎么解决
本来想讲前端性能优化的，图片懒加载，结果自个给忘了！！我就是个傻子！！
```

## 2021年7月22日浩鲸科技一面/尚融科技一面（均进二面）

#### 1.事件绑定：

```
*直接添加到元素上、比如
<button onclick="alert('Thank you');">点击这里</button>

*目标元素.onclick()这种方式只能给目标事件添加一个事件处理函数

*目标元素.addEventListener(click，事件处理函数) removeEventListener(事件类型，事件处理函数)

*目标元素.attachEvent(onclick，事件处理函数) deteachEvent(事件类型，事件处理函数)

Vue事件绑定：
<input type=‘button' v-on:click='num++'/>
<input type=‘button' @click='num++'/>

属性绑定：
<a v-bind:href='url'>跳转</a>
<a :href='url'>跳转</a>

双向数据绑定：
<a v-bind:href='url'>跳转</a>


事件对象event,event的属性是事件相关的信息，event的方法是事件的相关操作
添加删除事件处理函数是目标对象的
其他冒泡啊、默认行为、事件发生的目标元素全是绑定到事件上的。
```

#### 2.vue基础相关

```
v-on事件绑定
v-on:事件类型=“事件处理逻辑”/事件处理函数名称/事件处理函数调用,注这种凡事可以往事件处理函数中传递参数。
```

## 端点前端 二面面经：7-22

```
全程问场景+原理
1.如果一个用户在菜单里对应的路由 在URL输入后权限路由，不出现404，出现请联系拥有此权限的角色字样的页面
2.设计下国际化思路
3.路由哈希实现原理
4.vuex中inmotion数据的优点？单词没听清
5.definePropety缺点
6.unkonw 与 any
7.树摇原理
8.mv*原理
9.vux数据共享是吧，那为什么不单独写一个文件,所有模块一起调用它
10.vite3
```

## 抖音前端一面面经（凉）

#### 1算法：

```
1.合并有序数组
2.版本号排序
```

#### 2.看代码this指向

```js
var obj = {
    a: 1,
    func: function() {
        console.log(this);
        console.log(this.a);
    },
    func2: function() {
        var f = this.func;
        f();
    }
}

// func由obj对象调用，则this指向obj对象
// this.a就为1
obj.func();
// obj.func2()的执行使得f获得了func函数的引用
// f()直接让func执行了，并没有指向其他的啥对象，则就相当于一般函数的执行
// this指向全局window、this.a指向全局a，没有全局a则打印undefined
obj.func2();
// 同上func获取obj对象中func函数的引用,然后func函数执行
// this指向全局window，this.a指向全局a，无则打印undefined
var func = obj.func;
func();
this指向的问题关键是看是谁让函数执行的！！！
```

## 2021年内推阿里前端凉经 7.22

<img src="https://gitee.com/chenyipeng9/blog/raw/master/img/1149708C8DA3A4CFFFF3BC17E38C2C47.png" style="zoom: 33%;" />

<img src="https://gitee.com/chenyipeng9/blog/raw/master/img/D87394587E8D1F05C82F2880AABB839C.png" style="zoom:33%;" />

#### 2.最大子序和

## 京东前端一面凉经 7.23

```
项目相关：
1）怎样兼容不同的浏览器
2）移动端不同分辨率下怎样做适配
3）点击穿透问题和1px问题
4）以插件的方式封装组件（说代码）
5）项目中遇到的难点
自己项目用过什么css样式
代码格式化怎么做的？（使用了插件eslint、formate）

click 延时问题还可能引起点击穿透的问题，就是如果我们在一个元素上注册了 touchStart 的监听事件，这个事件会将这个元素隐藏掉，当这个元素隐藏后，就触发了这个元素下的一个元素的点击事件，这就是点击穿透。
```

## 京东前端一面二面面经 7.23

#### 1.Token为什么不放在cookie中，而放在了localStorage中

放到cookie里，发送请求自动携带上，CSRF攻击

你token放到cookie中指定http-only属性可以防止拿到cookie后去操作cookie避免XSS，比如document.cookie就看不到cookie的值了

#### 2.CI、DI持续集成？

```
持续集成[CI]：将软件个人研发的部分向软件整体部分交付，频繁进行集成以便更快地发现其中的错误。

持续部署[DI]：代码通过评审以后，自动部署到生产环境
```

#### 3.Uop的路由模式（history）？你还知道什么路由模式（hash）？

#### 4.代码格式化怎么做的？（使用了插件eslint、formate）

#### 5.百度地图地址逆解析？

```
逆地址解析：根据经纬度获得地址信息
地址解析：根据地址获得经纬度
```

#### 6.文件下载怎么做的？

```
1.后台服务器的静态目录有可供下载的静态资源，
后台人员告知你文件路径，直接window.location.href方式获取即可。
window.location.href="http://www.域名/template.xlsx(文件名)"

2.无可供下载的静态资源，返回的是一个文件流(response-type: application/octet-stream;charset=UTF-8 )，则使用第二种方式（将文件写入内存，并且创建a元素，a链接href属性指向内存中的文件，download属性指向要下载的文件名，模拟a元素的点击事件，进行下载；）

multipart/form-data：
该种方式也是一个常见的 POST 提交方，通常表单上传文件时使用该种方式。
```

## 字节前端一面面经

#### 1.CDN的原理，CDN回源策略

```
CDN内容分发网络，一般就是将主站的静态资源放在CDN服务器上，用户发起静态资源请求时，会去离他物理距离最近的CDN服务器上拿取资源，会提高资源响应速度。cookie隔离、客户端同一个域的连接数量只有6个等等

CDN回源策略问题，用户去离他最近的CDN服务器上找不到相关所要请求的资源，或是请求的资源已经失效了，CDN服务器就会去主站重新拿取。但是如果用户不去向CDN服务器请求资源，那CDN服务器不会主动去主站拿取

CND加速需要依靠各个网络节点，例如100台CDN服务器分布在全国范围，从上海访问，会从最近的节点返回资源，这是核心。CND服务器通过缓存或者主动抓取主服务器的内容来实现资源储备。
```

#### 2.算法题

```
算法题：删除一个字符串中的'b'元素，以及重复的'a'和'c'元素
例：'aabbc' -> 'ac' 、'aaabbbdccc' -> 'adc', 'aaa' -> 'a'
大数相加
```

#### 3.一个div盒子滑动如何知道它加载出来或是怎么的？题没太听懂...哭...（不知道是不是想问懒加载）

## 字节飞书-秋招提前批-前端一面面经

#### 1.数组和链表区别（这块还问到了系统是如何取链表加载到缓存的，这块不太理解她想问什么）

#### 2.看代码：

```js
var test = 'global'
const b = (function () {
    const test = 'scope';
    return { 
        test: '111',
        say() {
            var test = 'cccc';
            console.log(test);
    } };
}());
b.say(); // 'cccc'
// say执行上下文中有test变量，则直接用say执行上下文中的test变量cccc

var test = 'global'
const b = (function () {
    const test = 'scope';
    return { 
        test: '111',
        say() {
            console.log(test);
    } };
}());

// 闭包作用域链，变量沿着作用域链找
// return 出来的对象中的test属性，并不在say的变量对象中，所以也就不再作用域链上
// 考的是作用域链，如果say函数里面console.log(this.test)则考的是this指向问题，
// 则输出111
b.say(); // 'scope'
```

#### 3.一道算法题 根据字符串执行对象的链式调用，无法进行链式调用就返回给定的默认值

```
Question：实现一个 get函数
get(obj,chain,defaultVal)
举例：
const obj = {
    a:{
        b:[{
            c:1
        }]
    }
}

```

```
function get(obj, chain, defaultVal) {
    // [a,b[0],c]
    let arr = chain.split('.');
    for (let i = 0; i < arr.length; i++) {
        // 看有没有括号
        let index = arr[i].split('').indexOf('[');
        // 没有括号直接处理，直接处理了a和c
        if (index < 0) {
            if (obj[arr[i]]) {
                obj = obj[arr[i]];
            } else {
                return defaultVal;
            }
        } else {
            // 以b[0]为例
            // 有括号你就截取
            // pre就截取到了b
            // last就截取到了0
            let pre = arr[i].split('').slice(0, index).join('');
            let last = arr[i].split('').slice(index + 1, arr[i].length - 1).join();
            // 看obj[b]是不是数组，栏obj[b][0]数组中存不存在第一项
            if (Array.isArray(obj[pre]) && obj[pre][last]) {
                obj = obj[pre][last];
            } else {
                return defaultVal;
            }
        }
    }
    return obj;
}
console.log(get({
    a: {
        b: [{
            c: 1
        }]
    }
}, 'a.b[0].c', 5))
```

## shopee前端一面面经 7.25

#### 1.浏览器缓存

```
Web 缓存大致可以分为：数据库缓存、服务器端缓存（代理服务器缓存、CDN 缓存）、浏览器缓存。

浏览器缓存也包含很多内容： HTTP 缓存、indexDB、cookie、localstorage 等等。这里我们只讨论 HTTP 缓存相关内容。
```

#### 2.TS是JS的超集

## 京东前端二面面经，许愿7.26

#### 1.Sass 有了解吗（了解一点）

```
CSS的预处理器：
主要是给css提供了编程特性，比如函数、变量、循环啥的
```

#### 2.Webpack 怎么优化（说了压缩和 tree shaking，别的忘了，答得不太行）

```
1.给loader指定搜索范围，可以通过include， exclude字段
2.受限于Node是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，则可以通过相关配置进行多线程打包
比如：使用happypack等插件 ，快乐的打包就是能够让Webpack把打包任务分解给多个子线程去并发的执行
3.DllPlugin将特定的类库提前打包成动态链接库，之后要使用这个模块就直接去这个动态链接库中拿去，这种打包成all包的好处就是剩的老去打包那些不咋变化的类库
4.开启Tree-shaking，摇晃树。顾名思义就是当我们摇晃树的时候，树上干枯的没用的叶子就会掉下来。类比到我们的代码中就是将没用的代码摇晃下来,从而实现删除代码中未被引用的代码。
5.对文件进一步压缩，比如通过相关插件对打包后的图片进一步压缩处理
```

#### 3.了解大[前端](https://www.nowcoder.com/jump/super-jump/word?word=前端)和微服务这些吗（说了跨平台，别的也不知道了）

```
微服务架构风格是一种使用一套小服务来开发单个应用的方式途径，每个服务运行在自己的进程中，并使用轻量级机制通信，通常是HTTP API，这些服务基于业务能力构建，并能够通过自动化部署机制来独立部署，这些服务使用不同的编程语言实现，以及不同数据存储技术，并保持最低限度的集中式管理。方便扩展...
跨端开发：理解就是在不同的终端都能使用Write once, run everywhere。
```

## 字节跳动 前端一面面经 许愿二面顺利通过~

#### 1.虚拟内存和物理内存

```
每一个进程都有虚拟内存，它和物理内存之间存在映射关系，可以通过这层映射关系，从物理内存中拿到数据给进程使用。
```

<img src="https://gitee.com/chenyipeng9/blog/raw/master/img/20161105222328096.jfif" style="zoom: 80%;" />

#### 2.写树形结构？

```
function listToTree(srcList) {
    let result = [];
    let nodeInfo = srcList.reduce((data, node) => (data[node.id] = node, data), {});
    srcList.forEach(item => {
        if (!item.parentId) {
            result.push(item);
            return;
        }
        let parent = nodeInfo[item.parentId];
        parent.children = parent.children || [];
        parent.children.push(item);
    })
    return result;
}
const data = [
    { id: 10, parentId: 0, text: "一级菜单-1" },
    { id: 20, parentId: 0, text: "一级菜单-2" },
    { id: 30, parentId: 20, text: "二级菜单-3" },
    { id: 25, parentId: 30, text: "三级菜单-25" },
    { id: 35, parentId: 30, text: "三级菜单-35" }
];
console.log(listToTree(data))
```

## shein前端面经

#### 1.http返回301或302状态，如何拿到重定向的地址（从响应的Location首部获取）

#### 2.axios

```
8.axios的实现原理（1.原生XHR的封装2.Promise）
9.axios请求拦截器添加token
（config.headers.Authorization=localStorage.token）
10.axios配置公共请求前缀  axios.default s.baseUrl
```

#### 3.webpac如何导入整个模块（important * as example from ...）

## 字节基础架构前端一面面经

#### 1.vue bus的发布订阅和取消订阅分别都是怎么实现的

#### 2.看代码确定输出，变量对象以及this指向

打印b是变量对象沿着作用域链查找

this指向

```
var b = 'window';
function c() {
  console.log(b)
  console.log(this.b)
}

var obj = {
    b: '1-1',
    c:function(){
      console.log(b)
      console.log(this.b)
      return {
        b: '1-2',
        c: function() {
          console.log(b)
          console.log(this.b)
        }
      }
    },
}
c() window  window
obj = obj.c() window 1-1
obj.c = c
obj.c() window 1-2

//从第二步开始往下走的过程
console.log(obj)
obj = obj.c()
console.log(obj)
obj.c = c
console.log(obj)
obj.c()

输出结果：
{ b: '1-1', c: [Function: c] }
window
1-1
{ b: '1-2', c: [Function: c] }
{ b: '1-2', c: [Function: c] }
window
1-2
```

```
async function async1(){
    console.log('async1 start')
    await async2()
    console.log('async1 end')
}

async function async2(){
    console.log('async2')
}

console.log('script start')
setTimeout(function(){
    console.log('setTimeout') 
},0)  
async1();
new Promise(function(resolve){
    console.log('promise1')
    resolve();
}).then(function(){
    console.log('promise2')
})
console.log('script end')

script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout

```

#### 3.算法

螺旋打印矩阵

## 百度提前批 一面前端

项目详情及难点  20分钟

## 字节前端提前批一面面经

#### 1.OSI七层模型

应用层协议定义了应用进程间的交互和通信规则

传输层协议主要是为不同主机上的不同进程间提供了逻辑通信的功能

网络层协议主要实现了不同主机间的逻辑通信功能

数据链路层提供的服务是如何将数据报通过单一通信链路从一个结点移动到相邻节点

物理层提供的服务是尽可能的屏蔽掉组成网络的物理设备和传输介质间的差异

#### 2.算法：

```
算法：版本号排序，两二进制数相较输出十进制整数。
```

## 京东前端一面面经

#### 1.异步请求用promise封装，返回true和false可以接收

#### 2.vue-router的钩子，分别一般都用来写哪些代码

## 字节抖音前端三面凉经 

```
3.手写判断两个圆的关系
4.diff算法 —— 手写判断两棵树相等
```

## 蔚来一面面经（前端）

#### 1.两个div元素设置为inline-block，中间会有4px的间距，为什么？

```
换行符、空格符、制表符等合并为空白符，所以换行符会占据宽度，产生间隙。
给父元素添加font-size：0.可以解决
```

#### 2.稀疏数组？打印结果？(undefined)

ES5的几个方法基本上就是跳过并忽视空位，map方法是跳过但是保留空位，ES6将空位是为undefined

join，toString是undefined

## 非科班，前端开发，面经~长期更新 7.28

#### 1.编程思想--- oo面向对象

## 京东方前端一面面经

#### 1.Object.prototype.toString.call的原理

```
用于间接的查看对象的类属性，主要就是查看对象所属类的内部[[symbol.toStringTag]]属性
你自己创建一个类，然后这个类实例化一个对象，用这个方法返回的是默认的[object object],这时候你修改[[symbol.toStringTag]]属性就可以获取到不同的结果了

class Class2 {
  //指定symbol值的toStringTag 存取器属性的取回来的值，就是访问 toStringTag 属性时获取到的值
  get [Symbol.toStringTag]() {
    return "Class2";
  }
}
Object.prototype.toString.call(new Class2()); // "[object Class2]"
```

## 百度前端提前批一面

#### 1.Rax移动端长度单位是什么，原理是什么

```
rax跨端开发
```

#### 2.常见HTTP方法

```
get方法：获取资源
post方法：将报文实体中的内容进行上传
put方法：上传文件，完整的新体覆盖资源
delete方法：删除文件
opitions：获取指定资源所支持的方法(比如支持get、post等)
head：获得所要响应资源相关的报文首部
patch方法:应用于局部修改的资源
```

## 美团点评移动端（前端）提前批二面三面面经

#### 1.硬核

```
1.JS编译的顺序、JS编译后的代码与原先的代码怎么转换?扯了扯我了解的js
babel？转换

2.ES6 语法中的let/const 的实现
var会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针。
let是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错。
const也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过const存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性。

Promise是什么，怎么实现，口述实现思路？

你知道IFEE吗？知道，立即执行函数表达式（IIFE），最初的JS模块化方案
```

#### 2.算法题

```
链表中的节点每K个一组翻转
```

## 字节前端提前批二三面

#### 1.promise实现同一时间内限制并发请求数（常见题，描述略）

#### 2.手写合并两个有序数组，如何优化？

## 我是怎么失去成为东哥兄弟的机会的（京东前端面经）

#### 1.vue生命周期钩子函数8

#### 2.父子组件钩子函数执行顺序

#### 3.v-if和v-show的原理

```
基于数据驱动的理念，当 v-if 指令对应的 value 为 false 的时候会预先创建一个注释节点，value 发生变化时，命中派发更新的逻辑，将注释节点变为真实元素
```

#### 4.假如一根网线断了，TCP连接怎么断开

```
保活计时器? 每次服务器端接收到客户端的请求会重置宝活计时器，时间到了还没有接受到请求，服务器端会发送探测报文段，如果达到一定次数还没有收到，那就是客户端出现问题了就断开连接。
```

## 万兴内推实习前端（30分钟）还得去再再背背

#### 1.业务题

```
渲染上万条数据 
响应适配移动端方案  
纯js实施数据双向绑定的方案 
不用js点击框后改变颜色并保持
用户搜索时关键词优化
```

## 端点前端一面面经

#### 1.babel 相关

```
babel.config.js是Babel配置文件，

使用babel必须下载的三个官方的包

@babel/cli，Babel命令行转码工具，依赖@babel/core 

@babel/core ,  核心依赖

@babel/preset-env ，包提供了ES6转换ES5的语法转换规则

Babel的主要工作有两部分：语法转换、补齐API，但是Babel默认只转换新的JavaScript语法（syntax），而不转换新的 API。

让ES6新的API在低版本浏览器正常运行，我们就不能只做语法转换。前端web工程里，最常规的做法是使用polyfill，为当前环境提供一个垫片。polyfill广义上讲是为环境提供不支持的特性的一类文件或库
```

## 2022百度提前批前端一二三面面经

#### 1.模块化的理解

```
实现特定功能的一组方法

模块化的方式

第一种：几个函数就可以称之为模块，造成全局环境污染
第二种：利用对象来实现模块化，对象内部的方法还是会被外部访问到
第三种：立即执行函数来模拟私有作用域
```

## 滴滴提前批前端一二三面

#### 1.依赖收集在什么时候

```
beforemount 和 mounted之间
(依赖的数据变更了，就一定要做出处理，)
```

#### 2.diff算法

```
只会同一个节点进行比较否则就暴力删除旧的插入新的(选择器相同且key相同)
只进行同层比较，不会进行跨层比较，即使是同一片虚拟节点，但是跨层了，也是暴力删除旧的然后插入新的

vue3.0静态标记提高diff算法的效率
```

#### 3.前端和客户端通信

```
Android在js上下文注入一个JavascriptInterface，假设名为AndroidInterface，在前端可以直接以AndroidInterface.funName的形式调用。

Android 通过 loadUrl 直接加载页面链接
webview.loadUrl('https://www.google.com.hk/')

Android 通过loadUrl执行js的方法
webview.loadUrl('javascript: WebSpace.funName()')
```

#### 4.JS的函数重载

```
重载就是一组具有相同名字、不同参数列表的函数（方法）。

function overLoading() {
　　// 根据arguments.length，对不同的值进行不同的操作
　　switch(arguments.length) {
　　　　case 0:
　　　　　　/*操作1的代码写在这里*/
　　　　　　break;
　　　　case 1:
　　　　　　/*操作2的代码写在这里*/
　　　　　　break;
　　　　case 2:
　　　　　　/*操作3的代码写在这里*/
 　　　　　　
　　//后面还有很多的case......
}
 
}
```

#### 5.map和set有序吗

```
set有序 map无序
```

#### 6.如何判断是否存在内存泄漏

```
Chrome Devtool 提供了检查的工具，可以通过这个工具对页面中某一时刻的内存状态做一个快照，这个快照中包含此刻页面上所有的Dom节点和js对象。我们可以搜索可能泄露的js对象来证实内存泄漏的存在。
```

#### 7.如何跨域共享local Storage

```
postMessage 跨窗口间消息传递
```

## 京东-AI平台（提前批）

#### 1.一个没有遮罩层的弹框，点击周围关闭弹框，点击框体不关闭，怎么实现？

#### 2.SSO单点登录如何实现？不相关域名如何实现单点登录？

#### 3.「秒数」转成「小时:分钟:秒」如何实现？

```js

function dateFormat(second){
    let dd, hh, mm, ss;
    second = typeof(second)==='string'? ParseInt(second): second;
    if(!second||second<0) return 0;
    
    dd = second/(3600*24)|0;
    second = Math.round(second) - dd*(3600*24);
    
    hh = second/3600|0;
    second = Math.round(second) - hh*3600;
    
    mm = second/60|0;
    
    ss = Math.round(second)-mm*60;
    
    if(Math.round(dd)<10){
        dd = dd>0? '0' + dd : '';
    }
    if(Math.round(hh)<10){
        hh = '0' + hh;
    }
    if(Math.round(mm)<10){
        mm = '0' + mm;
    }
    if(Math.round(ss)<10){
        ss = '0' + ss;
    }
    
    return dd + ' ' + hh + ':' + mm + ':' + ss;
}
```

## 抖音前端（成都）提前批一面

#### 1.跨端开发相关问题以及傻逼的手写

```
聊项目

听你说你有过跨端开发经验，有了解过JS代码是如何运行在移动端的吗

说说JSBridge（不会）

用xhr手写axios（忘记API了，简单写了个promisify....）

手写MVVM（简单写了个用监听器代替模板解析的）
```

## 滴滴前端一二三面面经

#### 1.算法题

```js
//写1+2+....+n（递归）

function sumNum(n){
    return n && sumNum(n-1) + n; 
}
```

```JS
//求数组的交集并且不要有重复的数据

var intersection = function(nums1, nums2) {
    return [...new Set(nums1)].filter((item) => nums2.includes(item));
};
```

```js
//将对象中驼峰形式的键名转成下划线

function toLine(str){
    let reg = /[A-Z]|\d/g;
    return str.replace(reg,(item,index)=>{
        '_' + item.toLowerCase();
    })
}
//obj 为键名是驼峰形式的对象
//来个新的newObj来装
for(let item in obj){
    newObj[toLine(item)] = obj[item];
}
```

#### 2.动态规划和回溯法的区别，动态规划的自顶向下和自底向上的区别

```
动态规划的实现一般有两种一种是递归一种是迭代
递归采用的就是自顶向下：只有子问题完全求出，也就是子问题的递归返回结果，原问题才能求解。
从大问题到小问题
迭代采用的就是自底向上：从最小的子问题开始，自下而上求解。每次求新的问题时，子问题的解已经计算出来了。
从小问题到大问题

动态规划的核心就是base case 和 状态转移方程
```

## 滴滴前端一面凉经

#### 1如何正确判断null类型

```
Object.prototype.toString.call(null);
```

Object.prototype.toString.call方法一般我们就想到来间接的访问对象的类属性，然后他也是可以来判断基本数据类型的。

#### 2.TCP和UDP的应用场景

```
UDP的应用场景
进行视频聊天或者看直播，可以使用UDP协议，因为即使几个画面丢失了，对用户来说影响也不是很大
TCP的应用场景
发消息的场景以及文件传输，要确保发送的消息不丢失
```

#### 3.不考虑缓存和修改协议的情况下，可以通过哪些方式来最快地渲染页面呢，就是我们常说的关键渲染路径

```
关键渲染路径：
从html、css、js到页面上实际呈现的像素所经历的一系列过程
优化关键资源数量
优化关键路径长度
优化关键字节数
```

#### 4.判断代码是否可行

```
let声明的可以变，const声明的就变不了了，
这也是为啥const声明原始值数据不能再改变值的原因
主要就是因为原始值存在栈内存中，你const声明的哪块栈内存地址中存的就是原始值本身，所以原始值不能动了
但是你const声明对象，你哪块栈内存地址放的是对象在堆内存的地址，他就一直没有动过。

let a = {}; a=1;  

const b = {}; b=1;

const c = {}; c.a = 1;
```

#### 5.computed和watch支持对象的写法吗，就是说可以写一些get和set时候触发的

```
computed可以 watch应该不行

data: {
    firstName: 'Foo',
    lastName: 'Bar'
  },
  computed: {
  fullName：{
   get(){//回调函数 当需要读取当前属性值是执行，根据相关数据计算并返回当前属性的值
      return this.firstName + ' ' + this.lastName
    },
   set(val){//监视当前属性值的变化，当属性值发生变化时执行，更新相关的属性数据
       //val就是fullName的最新属性值
       console.log(val)
        const names = val.split(' ');
        console.log(names)
        this.firstName = names[0];
        this.lastName = names[1];
   }
   }
  }
  
  data: {
    firstName: 'Foo',
    lastName: 'Bar',
    fullName: 'Foo Bar'
  },
  watch: {
     firstName: function (val) {
     this.fullName = val + ' ' + this.lastName
  },
  lastName: function (val) {
     this.fullName = this.firstName + ' ' + val
   }
   }
```

## 虾皮前端一面凉经

#### 1.什么是稳定的排序算法，稳定排序算法有哪些

```
A、B相等，排序前A在B前面结果排完序B跑A前面了这就是不稳定排序
稳定排序：冒泡排序、插入、归并、基数排序
非稳定排序：选择、希尔、快排、堆
```

#### 2.看代码：

```
解构赋值：数组的解构赋值、对象的解构赋值
数组的展开运算符、
对象的展开运算符(相较于数组的展开运算符来说比较特别，相当于浅复制展开外面在包裹一个对象
{...{a:1}}这样不报错，...{a:1}报错，数组的展开运算符怎么用都可以)
函数的rest参数
都是不同的东西啊！！！
```

```
const objA = { a: 1 };
const objB = { b: 2 };
const arrA = [objA];
const arrB = [objB];

const v1 = arrA.concat(arrB);
const v2 = arrA.concat(...arrB);
const v3 = arrA.push(arrB);
const v4 = arrA.push(...arrB);
console.log(v1);
console.log(v2);
console.log(v3);
console.log(v4);

push方法返回的是你压入数组后数组的长度

```

```
非递归快排
```

## 蓝湖前端面试

#### 1.用js手写实现五子棋

## 端点前端一面面经

#### 1.token验证

## 字节国际电商前端一面面经（60min）

#### 1.代码题

```
1.（1）点击按钮计数+1
（2）多次点击隔一秒更新一次（节流）
（3）点击按钮重置
（4）父组件传入值，重置值为父组件传入的值
（写着写着就写成react了，哭）
```

## 商汤深圳 前端面经

```
编程题1：滑动窗口的最大值
编程题2：容器盛水问题
二分查找 时间复杂度
sort函数 底层用几路快排实现 时间复杂度：数组长度小于10用插入排序，大于10用快排
```

## 拼多多提前批前端面经

#### 1.Promise.all是有一个错误就返回还是等所有promise都执行完，如果要等所有promise执行完再返回怎么办。

```js
/*
Promise.all用于将一组Promise实例包装成一个Promise实例
只有这一组Promise实例的状态都为resolved我包装的才会为resolved
只要其中有一个为rejected包装的Promise实例就为rejected
为了让这组中rejected的promise实例接着往下走
可以给这组的每个promise实例都catch一下
*/

let p1 = new Promise((resolve, reject) => {
    setTimeout(() => reject(1), 1000);
}).catch(reason => new Promise(resolve => {
    resolve(`我是错的${reason}`);
}));
let p2 = new Promise((resolve, reject) => {
    setTimeout(() => resolve(2), 2000);
}).catch(reason => new Promise(resolve => {
    resolve(`我是错的${reason}`);
let p3 = new Promise((resolve, reject) => {
    setTimeout(() => resolve(3), 3000);
}).catch(reason => new Promise(resolve => {
    resolve(`我是错的${reason}`);
const p = Promise.all([p1, p2, p3])
.then(data => console.log(data))
.catch(reason => { console.log(reason) })
```

#### 2.手写代码给一个url和key,获取对应key的值

## 拼多多前端一面面经

#### 1.字符串的slice、substr、substring都是将截下来的部分加以返回

#### 2.那些默认行为：

```
点击链接跳转刷新页面
点击提交按钮提交表单
```

#### 3.对前端工程化的理解

前端工程化就是为了让前端开发能够“自成体系”，个人认为主要应该从**模块化**、**组件化**、**规范化**、**自动化**四个方面思考。

**模块化：**将一个大文件拆分成相互依赖的小文件，再进行统一的拼装和加载。(**WebPack**)

**组件化：**模块化只是在文件层面上，对代码或资源的拆分；组件化是在设计层面上，对UI（用户界面）的拆分。

**规范化：**规范制定的好坏会直接影响到后期的开发质量。

**自动化：**任何简单机械的重复劳动都应该让机器去完成。

#### 4.手写题 promise的超时重新请求，参数（fn，times，interval）

##  字节今日头条提前批前端一面凉经

#### 1.Promise中then的链式调用怎么使用

```
then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。
因此可以采用链式写法，即then方法后面再调用另一个then方法。
上一个Promise then方法中return的结果是下一个promise then方法中回调函数的参数
```

#### 2.function的length表示什么

```
排除掉那些带有默认值的形参，的形参个数
```

## 百度提前批前端一面面经

#### 1.扩展运算符一般用在什么数据类型上

```
展开运算符可以用于数组和对象的浅复制
展开运算符可以将原生具有iterator接口的数据转为数组
原生具有iterator接口的数据有：
字符串、map、set、arguments、nodeList、TypeArray
```

## 大华前端一面面经

#### 1.webworker传递参数

```js
//主线程采用new命令，调用Worker()构造函数，新建一个 Worker 线程。
var worker = new Worker('work.js');
//主线程调用worker.postMessage()方法，向 Worker 发消息。
worker.postMessage('Hello World');
worker.postMessage({method: 'echo', args: ['Work']});
//主线程通过worker.onmessage指定监听函数，接收子线程发回来的消息
worker.onmessage = function (event) {
  console.log('Received message ' + event.data);
  doSomething();
}

function doSomething() {
  // 执行任务
  worker.postMessage('Work done!');
}
//Worker线程内部一样postMessage和onMessage 
```

## 大华前端一面面经（大概40min）

#### 1.v-model原理，另一种方法实现数据绑定效果，这个答的不好，太菜了，对于vue相关知识掌握的不好

## 百度前端提前批一面

#### 1.vue插槽

**一般插槽的使用**

```
父组件中使用：
<alert-box>有bug发生</alert-box>
填到子组件的
<slot>默认内容</slot>
```

**具名插槽**

```
在父组件中使用
<template slot='header'>
   <p>标题信息1</p>
   <p>标题信息2</p>
</template>
填充到子组件的
<slot name='header'></slot>
```

**作用域插槽，将子组件中的数据拿到父组件中接着处理**

```
 子组件中通过info属性绑定到数据的每一项
 <slot :info='item'>{{item.name}}</slot>
 父组件中拿到数据加以处理，关键是slot-scope，
 <template slot-scope='slotProps'>
 <strong v-if='slotProps.info.id==3' class="current">{{slotProps.info.name}}</strong>
 <span v-else>{{slotProps.info.name}}</span>
 </template>
```

## 百度提前批前端一面凉经

#### 1.场景题：明文密码

需要传递一些明文的数据（卡号）过来怎么确保安全。 

期间说了下md5和base64 讲了可以混淆加密。和后端约定规则，面试官说这个治标不治本 

面试官说还可以直接前端不做，后端不传递明文过来,前端拿到卡号没意义，只传id，这个叫做 脱敏

```
md5、base64加密
md5和base64 可以混淆加密并和后端约定规则

```

#### 2.巴拉巴拉题

```
web storage下，想在本地请求存储，（本地存储的更新策略，利用storage怎么高效？？）我先说可以走协商缓存，面试官说是静态资源和浏览器内部的处理。。，类似缓存怎么做。没太懂，就说了下跟协商缓存差不多的etag比较哈希，，，面试官也没说啥
```

## 字节跳动抖音前端，一二三面HR面面经

#### 1算法题

```
1.蛇形遍历二叉树，其实也就是二叉树BFS遍历的变形，好像是剑指offer32
2.考察二分查找的应用
```

## 阿里前端一二面凉经

#### 1.问我做过最有成就感的事（说实话这个是第一次问到这个问题，也不知道该咋说，难受）

## 蓝湖前端一面面经

#### 1.vue2.0里对数组的绑定是怎么实现的

```
提供了观察数组的变异方法
定义并覆盖了原生数组方法，从而达到监听数组变化的能力，之后数组数据变化通知所有注册的观察者进行响应式处理。
主要就是依赖收集和通知更新
```

## 2021.8.4 深圳领星 前端一面面经

#### 1.实现骰子1-5点的概率为10%，6点的概率为50%

## 字节一面凉经

#### 1.文件下载

```
1.后台服务器的静态目录有可供下载的静态资源，
后台人员告知你文件路径，直接window.location.href方式获取即可。
window.location.href="http://www.域名/template.xlsx(文件名)"

2.无可供下载的静态资源，返回的是一个文件流(response-type: application/octet-stream;charset=UTF-8 )，则使用第二种方式（将文件写入内存，并且创建a元素，a链接href属性指向内存中的文件，download属性指向要下载的文件名，模拟a元素的点击事件，进行下载；）

multipart/form-data：
该种方式也是一个常见的 POST 提交方，通常表单上传文件时使用该种方式。
```

## CVTE提前批一面面经

#### 1.变量对象看代码

```js
let a = 1;
function fnB() {
    let a = 2;
    return function() {
        a++;
        //区别在这里匿名函数执行完
        //即将进入fnA的执行上下文，你这个fnA()没有传参
        //我解释器会认为你不需要用到相关变量
        //就把你下面由匿名-》fnB-》全局中的，匿名-》fnB给断掉
        //这样就直接fnA-》全局
        //后面我fnA中的变量A就用的全局的
        fnA();
    }
}
function fnA() {
    console.log(a);
}
console.log(fnB()())
//输出结果为1
```

```js
let a = 1;
function fnB() {
    let a = 2;
    return function() {
        a++;
        //进入fnA函数的执行上下文时，携带了需要使用变量a
        //这样一个操作，所以fnB执行上下文变量对象中的变量a就保存着没有被销毁了
        fnA(a);
    }
}
function fnA(m) {
    console.log(m);
}
console.log(fnB()())
//输出结果为3
```

```js
let a = 1;
function fnB() {
    let a = 2;
    return function() {
        a++;
        //fnB执行返回的匿名函数执行时需要用到a
        //则fnB执行上下文变量对象中的变量a就保存了下来没有被销毁
        console.log(a);
    }
}
console.log(fnB()())
//输出结果为3
```

```js
let i = 0;
const FnA = () => {
    console.log(1);  //1
    return new Promise((resolve) => {
        //promise状态改变扔出去结果，就是扔出去了，你不能动了啊
        //你这里就是扔出去了0，我知道他会变成1，但是变成1，你promise的回调也没有办法拿了
        resolve(i++);
    })
}
const a = FnA();
setTimeout(() => {
    console.log(2);  //2
    a.then((result) => console.log(result));  //0
}, 0);

console.log(3);  //3
console.log(i);  //1 //但是同步这里可以拿到你加加后的1
a.then(result => { console.log(result) });  //0
//1 3 1 0 2 0
```

#### 2.**什么是CSRF攻击？攻击流程？黑客用什么手段盗取cookie？**

```
冒用cookie
用户用浏览器访问A网站，此时浏览器记录了A网站的cookie，当用户被诱导至B网站，B网站恶意向A网站发送请求，则浏览器会自动带上cookie去向A网站发起请求。
浏览器会依据加载的域名附带上对应域名cookie。

就是如果用户在a网站登录且生成了授权的cookies，然后访问b网站，b站故意构造请求a站的请求，如删除操作之类的，用script，img或者iframe之类的加载a站着个地址，浏览器会附带上a站此登录用户的授权cookie信息，这样就构成crsf，会删除掉当前用户的数据。
注释：script、image、iframe的src都不受同源策略的影响。所以我们可以借助这一特点，实现跨域
```

## 字节抖音前端一面面经

#### 1.let 变量提升看代码

```js
var x = 3
if (x) {
    var x = 2
}
console.log(x)
//结果为2

let x = 3
if (x) {
    x = 2
}
console.log(x)
//结果为2

let x = 3
if (x) {
    let x = 2
}
console.log(x)
//结果为3
```

#### 2.TCP UDP区别、应用场景

```
UDP的应用场景
进行视频聊天或者看直播，可以使用UDP协议，因为即使几个画面丢失了，对用户来说影响也不是很大
TCP的应用场景
发消息的场景以及文件传输，要确保发送的消息不丢失
```

## 字节跳动 前端实习 一面+二面

#### 1.看代码

```js
var a = 1;
function b() {
    //函数作用域局部变量a函数 var a = function
    //后重新赋值为一个变量10
    //不出函数作用域
    a = 10;
    return;
    function a() {}
}
b();
//所以这里打印的是全局a  1
console.log(a);

var a = 1;
function b() {
    //这里就是全局变量a修改了
    //上面那个就是相当于函数内部 var a=..，这样进行局部变量定义了
    a = 10;
    return;
}
b();
//所以这里打印的是修改格式后的全局a
console.log(a);//10
```

#### 2.转成指定格式1123456789 -> 1,123,456,789

```js
1123456789.toLocalString('en');
```

## 蓝湖前端一二三面面经

#### 1合成层

```
RenderLayers 来保证页面元素以正确的顺序合成，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示。满足某些特殊条件的渲染层，会被浏览器自动提升为合成层。合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 的父层共用一个。
```

#### 2.vue路由异步加载原理(路由懒加载)

#### 3.PM2负载均衡守护进程

## 字节跳动日常实习前端二面面经

#### 1.手写Node 的 Promisify

#### 2.算法

```
数组的子序列最大和
```

## 字节商业化技术前端一面面经

#### 1.看代码

```js
var F = function () { }
Object.prototype.a = function () {
    console.log('a')
}
Function.prototype.b = function () {
    console.log('b')
}
var f = new F();
f.a(); 
f.b();
F.a();
F.b();

a 报错 a b
/*
function A(){};
let a = new A();
Object.getPrototypeOf(Object.getPrototypeOf(a))===Object.prototype  true
Object.getPrototypeOf(Object.getPrototypeOf(A))===Object.prototype  true
A函数如果作为构造函数使用，则A.prototype的原型对象的原型对象为Object.prototype
A函数作为一般函数使用，则Object.getPrototypr(A)则指向函数类Function的原型对象即Function.Prototype
Function的原型对象Function.Prototype的原型对象指向Object.prototype即顶层原型对象
*/
```

#### 2.还问了如何不使用额外变量交换变量a,b的值

```js
//解构赋值
let a = 1,
    b = 2;
console.log(a, b);
[a, b] = [b, a];
console.log(a, b); 
```

## 字节跳动-新业务-前端 一面凉经

#### 1.看代码

```js
var tmp = 'hello'
function f() {
    console.log(tmp);
    if (false) {
        //这里变量提升，函数内部tmp是undefined
        //没有进来tmp就没被赋值
        var tmp = 'hello world';
    }
}
f(); //undefined

//========================================

var tmp = 'hello'
function f() {
    console.log(tmp);
    if (false) {
		//函数作用域内部没有temp
        tmp = 'hello world';
    }
}
f(); //hello
```

## 深圳虾皮提前批前端面经

#### 1.算法：手写快排和归并排序

## 字节前端三面面经

```
vue 兄弟组件的通信方式?EventBus用的什么模式
```

## 端点 前端二面面经

```
搜索框实现流程
```

## 字节前端一二三面面经

#### 1.Object.create()有哪些参数

```
第一个参数：新对象的原型对象
第二个参数：新对象指定的属性,是一个对象形式的配置
value: 属性的默认值， 默认为undefined
congigurable: 能否使用delete、能否修改属性特性、或能否修改访问器属性、false为不可重新定义，默认值为true
enumberable: 可枚举性，对象属性能否通过for-in 循环，默认为true
writable: 对象属性是否可修改，默认为true，可修改，设置false可理解为常量不可修改
```

#### 2.双等号的隐式类型转换

```
if ([])
if ({})
if ([] == []) //只有这个是false，其他的全是true
if ([] == "")
if (0 == "")
+0 -0 NaN null undefined false转成false其他转为true
[] "" false null 转为0
```

#### 3.websocket基于什么协议：TCP

#### 4.express中间件的原理

```
express内部维护一个函数数组，这个函数数组表示在发出响应之前要执行的所有函数，也就是中间件数组
使用app.use(fn)后，传进来的fn就会被扔到这个数组里，执行完毕后调用next()方法执行函数数组里的下一个函数，如果没有调用next()的话，就不会调用下一个函数了，也就是说调用就会被终止
```

#### 5.算法

```
调整数组使奇数在前偶数在后，保证顺序，不使用额外空间
```

## 百度提前批前端一面面经

#### 1.v-for和v-if的渲染优先级

```
显然v-for优先于v-if被解析，v-for的优先级大于v-if。
```

#### 2.你怎么看待一个网页的结构

#### 3.关于高质量代码的编写

#### 4.幽灵空白结点

```
没有指定高度也占据了空间
父级元素指定fontSize：0；
```

#### 5.css高耗能属性

```
box-shadow、border-radius、:nth-child
```

#### 6.0.5px实现方法 为什么能实现？那0.1px能实现吗？

```
transform:scaleY(0.5);
```

#### 7.平时用if else 还是用switch？ 两者原理、区别和使用场景

```
switch case会生成一个跳转表来指示实际的case分支的地址，
而if…else却需要遍历条件分支直到命中条件，
switch 优点就是效率高，缺点就是case常量，适用范围较少
```

#### 8.堆排序 快排 时间复杂度

```
o(nlogn) o(1)
```

#### 9.vue里面的修饰符(事件修饰符)

```
.stop阻止冒泡
.prevent阻止默认行为
```

#### 10.字符串’0’和’000’和true比较的结果

```
false
```

#### 11.Git如果commit了内容想要回退该怎么做

```
git reset --soft HEAD^
HEAD^的意思是上一个版本，也可以写成HEAD~1
进行了2次commit，想都撤回，可以使用HEAD~2
```

#### 12.微信小程序的理解

```
依赖于微信手机APP，在微信生态圈中跑
相对于原生的APP和webapp的产品来说，微信小程序不需要下载程序的安装包进行安装，也不存在版本的升级对于消费端产生的需要更新的负担；
```

#### 13.Vue.filter()全局过滤器，局部过滤器

```js
    var vm = new Vue({
      el: '#app',
      data: {
        msg: ''
      },
      // 局部过滤器，在vue实例中添加filters属性
      // 只能在本组件中使用
      filters: {
        // 属性名是过滤器的名称
        // 属性值是过滤器要实现的业务逻辑
        upper: function(val) {
          return val.charAt(0).toUpperCase() + val.slice(1);
        }
      }
    });

    Vue.filter('lower', function(val) {
      return val.charAt(0).toLowerCase() + val.slice(1);
      // 数据被过滤功能处理后需要加以返回
    });
```

#### 14watch和computed，watch会影响性能吗？

#### 15.原生JS怎么监听滚动的事件-onscoll事件

#### 16.Vue的render函数

```
render函数中传递的回调函数h将传入的vue单文件组件替换掉el控制的区域
```

#### 17.父组件怎么拿到子组件的实例

```js
      components: {
        'hello-world': HelloWorld,
        'hello-tom': HelloTom,
        'hello-jerry': HelloJerry
      }
//将局子组件在父组件中进行注册
```

#### 18.虚拟DOM，除了性能方面的优势，还有其他优点吗

```
保证性能下限：

无需手动操作 DOM：我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；

跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等
```

#### 19.Vue怎么监听数组的变化

```
重写数组的方法，将数组作为对象的属性进行数据劫持，进而实现响应式
```

#### 20.9.口述归并排序

## 字节互娱前端二面面经

#### 1.懒加载

```
intersectionObserve api 提供了一种异步观察目标元素与其祖先元素或顶级文档视窗(viewport)交叉状态的方法
```

#### 2.实现Tooltip

## 百度提前批前端一面面经

#### 1.怎么用es5语法实现const

```
将存取器属性的特性改为不可配置，不可枚举，关键是set重写
```

#### 2.etag的缺点

```
开销大，加重服务器端负担
```

## 远景智能 前端一面面经 电话面试 40min

#### 1.diff算法的过程

```
diff算法主要就是用来精细化比较从而进行最小量更新的
过程概括：一边比较前后两个虚拟节点，一边根据比较的结果对真实的dom节点进行打补丁
特点是只能同层比较不能跨层比较
具体diff过程：
看vNode和oldNode是不是同一个节点，如果不是，直接删除旧的插入新的
如果是继续比较：
都有文本节点，只是文本内容不同，则将vNode中的文本内容，更新到真实的dom节点中
vnode没有子节点，oldNode有子节点，则在真实的dom上将子节点删去
vnode有子节点，oldNode没有子节点，则将vnode的子节点转成真实的dom结构，挂载到dom树上
vnode有子节点，oldNode有子节点
则分别有前后两个指针，指向vnode和oldNode，四种比较方式，找到匹配位置，将真实dom节点移动到vnode对应的匹配位置，如果四种匹配都没有，则遍历oldNode和vnode头结点进行匹配，将匹配到的真实dom节点移动到vnode头指针对应的头部。
```

#### 2.怎么处理数组监听的

```
Vue响应式一般思想：
observe、dep、watcher、
observe用于将data中的数据全部转成响应式的，主要就是借助definproperty中的get、set方法、进行数据的拦截操作
当获取数据时触发对应get，在里面借用dep进行依赖收集，也就是收集watcher，
当修改数据时，触发set，在里面根据之前收集到的watcher进行相关回调的执行

对于数组的响应式而言：
如果直接用get、set拦截，响应式绑定数组数据则对于数组的length属性不能进行拦截，此外对每一个索引位置的数据都单独响应式，太消耗资源了。
Vue做的事就是用defineProperty来拦截数组方法本身，具体就是用数值属性的value内部特性来重写数组方法，在这重写的方法里面既使用原生的所要重写的数组方法去拿到用户本来要进行的数组操作结果，又进行了相关响应式的操作，比如通知视图更新，这些重写的方法都依托与一个对象，也就是defineProperty中的第一个参数，后续就是将你的数组数据即数组实例指向这个对象，具体的操作就是浏览器是否支持_proto_支持的话，直接数组实例通过它指过去就行，如果不支持，那就将重写的方法直接绑到数组实例上就行了。
```

#### 3.实现一个块从左上角到右下角移动

#### 4.字符串的拼接

```
'a'.concat('bb')
```

## 字节

#### 1看代码

```js
async function async1() {
    console.log('async1 start');
    await async2()
    //等执行到这一步再将它放入微任务队列中
    console.log('async end');}
async function async2() {
    // 关键就在这个return语句，你return了那么你async2异步函数
    // 执行返回的promise就要携带结果，结果哪里来？结果在这一轮微任务队列执行后产生
    // 所以await async2()后面的代码必须等这一轮微任务队列开始执行了才能入队列
    // 而如果你没有这个return，直接new promise那么你async2函数返回的promise的状态在你resolve的时候
    // 就会改变，而await async2() 其后async2状态一旦改变就会执行后面的代码，所以这一轮事件循环
    //  console.log('async end');就会入微任务队列
    return new Promise((resolve, reject) => {
        console.log('async2 start');
        resolve()
    }).then(res => {
        console.log('async2 end');
    })}
setTimeout(() => { console.log('setTimeout') }, 0)
async1()
new Promise(resolve => {
    console.log('Promise');
    resolve()
}).then(res => {
    console.log('Promise end');})
console.log('script end');
async1 start
async2 start
Promise
script end
async2 end
Promise end//先下面一步进入微任务队列
async end//async1中await执行完后放入微任务队列的
setTimeout//宏任务队列
```

```js
async function async1() {
    console.log('async1 start');
    await async2()
    console.log('async end');
}
async function async2() {
    // 这里我不要这个return
    new Promise((resolve, reject) => {
        console.log('async2 start');
        resolve()
    }).then(res => {
        console.log('async2 end');
    })
}
setTimeout(() => { console.log('setTimeout') }, 0)
async1()
new Promise(resolve => {
    console.log('Promise');
    resolve()
}).then(res => {
    console.log('Promise end');
})
console.log('script end');

async1 start
async2 start
Promise
script end
async2 end
async end
Promise end
setTimeout
```


```js
async  function  async1()  {  
    console.log('async1 start');  
    await  async2();  
    console.log('async1 end');}
async  function  async2()  {  
    console.log('async2 start');  
    //没有这一坨东西console.log('async1 end');，他就先放到微任务队列中去
    //有的话，他就只能往后排排站了
    // return  new  Promise((resolve,  reject)  =>  { resolve();    
    //     console.log('async2 promise');})
}
console.log('script start');
setTimeout(function()  {  
    console.log('setTimeout');},  0);
async1();
new  Promise(function(resolve)  {  
    console.log('promise1');  
    resolve();
}).then(function()  {  
    console.log('promise2');
}).then(function()  {  
    console.log('promise3');
});
console.log('script end');
script start
async1 start
async2 start
promise1
script end
async1 end
promise2
promise3
setTimeout
```

```js
async  function  async1()  {  
    console.log('async1 start');  
    await  async2();  
    console.log('async1 end');}
async  function  async2()  {  
    console.log('async2 start');  
    return  new  Promise((resolve,  reject)  =>  { resolve();    
    console.log('async2 promise');})
}
console.log('script start');
setTimeout(function()  {  
    console.log('setTimeout');},  0);
async1();
new  Promise(function(resolve)  {  
    console.log('promise1');  
    resolve();
}).then(function()  {  
    console.log('promise2');
}).then(function()  {  
    console.log('promise3');
});
console.log('script end');
script start
async1 start
async2 start
async2 promise
promise1
script end
promise2
promise3
async1 end
setTimeout
```

```
async  function  async1()  {  
    console.log('async1 start');  
    await  async2();  
    console.log('async1 end');
}
async  function  async2()  {  
    console.log('async2 start');  
    new  Promise((resolve,  reject)  =>  { 
        resolve();    
        console.log('async2 promise');
    })
}
console.log('script start');
setTimeout(function()  {  
    console.log('setTimeout');
},  0);
async1();
new  Promise(function(resolve)  {  
    console.log('promise1');  
    resolve();
}).then(function()  {  
    console.log('promise2');
}).then(function()  {  
    console.log('promise3');
});
script start
async1 start
async2 start
async2 promise
promise1
async1 end
promise2
promise3
setTimeout
```

#### 阿里

```

```

